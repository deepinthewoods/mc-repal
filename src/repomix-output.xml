This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-11T13:15:04.715Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/config/LayerImportExport.java
client/java/ninja/trek/config/LayerManagementUI.java
client/java/ninja/trek/config/RepalModMenu.java
client/java/ninja/trek/config/TextureComboBox.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/ProcessedTextureCache.java
client/java/ninja/trek/RepalClient.java
client/java/ninja/trek/RepalDataGenerator.java
client/java/ninja/trek/TextureManager.java
client/java/ninja/trek/TextureProcessor.java
client/resources/repal.client.mixins.json
main/java/ninja/trek/config/RepalConfig.java
main/java/ninja/trek/ImageProcessor.java
main/java/ninja/trek/LayerInfo.java
main/java/ninja/trek/LayerManager.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/java/ninja/trek/PaletteInfo.java
main/java/ninja/trek/Repal.java
main/java/ninja/trek/RepalResourceReloadListener.java
main/resources/assets/repal/lang/en_us.json
main/resources/fabric.mod.json
main/resources/repal.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/config/LayerImportExport.java">
package ninja.trek.config;
import com.google.gson.*;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.CheckboxWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import ninja.trek.LayerInfo;
import ninja.trek.LayerManager;
import ninja.trek.Repal;
import net.fabricmc.loader.api.FabricLoader;
import java.nio.file.*;
import java.util.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
public class LayerImportExport {
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();
    private static final Path PRESETS_DIR = FabricLoader.getInstance()
            .getGameDir()
            .resolve("config")
            .resolve("repal")
            .resolve("presets");
    public static void exportLayers(String presetName) {
        try {
            Files.createDirectories(PRESETS_DIR);
            // Create export data structure
            JsonObject exportData = new JsonObject();
            exportData.addProperty("name", presetName);
            exportData.addProperty("timestamp",
                    LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
            // Add layers data
            JsonArray layersArray = new JsonArray();
            for (LayerInfo layer : LayerManager.getInstance().getAllLayers()) {
                JsonObject layerObject = new JsonObject();
                layerObject.addProperty("name", layer.getName());
                layerObject.addProperty("contrast", layer.getContrast());
                layerObject.addProperty("saturation", layer.getSaturation());
                layerObject.addProperty("palette", layer.getPalette());
                // Add textures
                JsonArray texturesArray = new JsonArray();
                for (Identifier texture : layer.getTextures()) {
                    texturesArray.add(texture.toString());
                }
                layerObject.add("textures", texturesArray);
                layersArray.add(layerObject);
            }
            exportData.add("layers", layersArray);
            // Save to file
            String filename = presetName.replaceAll("[^a-zA-Z0-9.-]", "_") + ".json";
            Path exportPath = PRESETS_DIR.resolve(filename);
            Files.writeString(exportPath, GSON.toJson(exportData));
            Repal.LOGGER.info("Exported layer preset to: {}", exportPath);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to export layers", e);
        }
    }
    public static List<String> getAvailablePresets() {
        List<String> presets = new ArrayList<>();
        try {
            Files.createDirectories(PRESETS_DIR);
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(PRESETS_DIR, "*.json")) {
                for (Path path : stream) {
                    String filename = path.getFileName().toString();
                    presets.add(filename.substring(0, filename.lastIndexOf('.')));
                }
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to list presets", e);
        }
        return presets;
    }
    public static boolean importLayers(String presetName) {
        try {
            Path importPath = PRESETS_DIR.resolve(presetName + ".json");
            if (!Files.exists(importPath)) {
                Repal.LOGGER.error("Preset file not found: {}", importPath);
                return false;
            }
            String jsonContent = Files.readString(importPath);
            JsonObject importData = JsonParser.parseString(jsonContent).getAsJsonObject();
            LayerManager layerManager = LayerManager.getInstance();
            layerManager.reset(); // Clear existing layers
            JsonArray layersArray = importData.getAsJsonArray("layers");
            for (JsonElement layerElement : layersArray) {
                JsonObject layerObject = layerElement.getAsJsonObject();
                // Create new layer
                LayerInfo layer = layerManager.createLayer(
                        layerObject.get("name").getAsString()
                );
                // Set layer properties
                layer.setContrast(layerObject.get("contrast").getAsInt());
                layer.setSaturation(layerObject.get("saturation").getAsInt());
                layer.setPalette(layerObject.get("palette").getAsString());
                // Add textures
                JsonArray texturesArray = layerObject.getAsJsonArray("textures");
                for (JsonElement textureElement : texturesArray) {
                    layer.addTexture(Identifier.of(textureElement.getAsString()));
                }
            }
            return true;
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to import preset: {}", presetName, e);
            return false;
        }
    }
}
public class PresetManagementUI {
    private final MinecraftClient client;
    private final int x;
    private final int y;
    private final int width;
    private ButtonWidget importButton;
    private ButtonWidget exportButton;
    private TextFieldWidget presetNameField;
    private List<String> availablePresets;
    private int selectedPresetIndex = -1;
    private static final int BUTTON_HEIGHT = 20;
    private static final int FIELD_HEIGHT = 20;
    private static final int SPACING = 4;
    private static final int LIST_HEIGHT = 100;
    public PresetManagementUI(MinecraftClient client, int x, int y, int width) {
        this.client = client;
        this.x = x;
        this.y = y;
        this.width = width;
        this.availablePresets = LayerImportExport.getAvailablePresets();
    }
    public void init() {
        int currentY = y;
        int halfWidth = (width - SPACING) / 2;
        presetNameField = new TextFieldWidget(
                client.textRenderer,
                x,
                currentY,
                width,
                FIELD_HEIGHT,
                Text.empty()
        );
        presetNameField.setMaxLength(32);
        presetNameField.setPlaceholder(Text.translatable("repal.preset.name.placeholder"));
        currentY += FIELD_HEIGHT + SPACING;
        importButton = ButtonWidget.builder(Text.translatable("repal.preset.import"), this::onImportClick)
                .dimensions(x, currentY, halfWidth, BUTTON_HEIGHT)
                .build();
        exportButton = ButtonWidget.builder(Text.translatable("repal.preset.export"), this::onExportClick)
                .dimensions(x + halfWidth + SPACING, currentY, halfWidth, BUTTON_HEIGHT)
                .build();
        updateButtonStates();
    }
    private void updateButtonStates() {
        boolean hasValidName = !presetNameField.getText().trim().isEmpty();
        boolean hasSelection = selectedPresetIndex >= 0;
        importButton.active = hasSelection;
        exportButton.active = hasValidName;
    }
    private void onImportClick(ButtonWidget button) {
        if (selectedPresetIndex >= 0 && selectedPresetIndex < availablePresets.size()) {
            String selectedPreset = availablePresets.get(selectedPresetIndex);
            if (LayerImportExport.importLayers(selectedPreset)) {
                // Success notification would go here
            }
        }
    }
    private void onExportClick(ButtonWidget button) {
        String presetName = presetNameField.getText().trim();
        if (!presetName.isEmpty()) {
            LayerImportExport.exportLayers(presetName);
            availablePresets = LayerImportExport.getAvailablePresets();
            // Success notification would go here
        }
    }
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        // Draw preset name field
        presetNameField.render(context, mouseX, mouseY, delta);
        // Draw buttons
        importButton.render(context, mouseX, mouseY, delta);
        exportButton.render(context, mouseX, mouseY, delta);
        // Draw available presets list
        int listY = y + FIELD_HEIGHT + BUTTON_HEIGHT + SPACING * 2;
        context.fill(x, listY, x + width, listY + LIST_HEIGHT, 0x80000000);
        int entryHeight = 20;
        int scrollOffset = 0;
        for (int i = 0; i < availablePresets.size(); i++) {
            int entryY = listY + i * entryHeight - scrollOffset;
            if (entryY >= listY && entryY + entryHeight <= listY + LIST_HEIGHT) {
                boolean isSelected = i == selectedPresetIndex;
                if (isSelected) {
                    context.fill(x, entryY, x + width, entryY + entryHeight, 0x80808080);
                }
                context.drawTextWithShadow(
                        client.textRenderer,
                        availablePresets.get(i),
                        x + 4,
                        entryY + 6,
                        isSelected ? 0xFFFFFF : 0xAAAAAA
                );
            }
        }
    }
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (presetNameField.mouseClicked(mouseX, mouseY, button)) {
            return true;
        }
        // Handle preset list clicks
        int listY = y + FIELD_HEIGHT + BUTTON_HEIGHT + SPACING * 2;
        if (mouseX >= x && mouseX < x + width &&
                mouseY >= listY && mouseY < listY + LIST_HEIGHT) {
            int entryHeight = 20;
            int clickedIndex = (int)((mouseY - listY) / entryHeight);
            if (clickedIndex >= 0 && clickedIndex < availablePresets.size()) {
                selectedPresetIndex = clickedIndex;
                updateButtonStates();
                return true;
            }
        }
        return false;
    }
    public List<ButtonWidget> getButtons() {
        return Arrays.asList(importButton, exportButton);
    }
    public void tick() {
        presetNameField.tick();
    }
}
</file>

<file path="client/java/ninja/trek/config/LayerManagementUI.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import ninja.trek.LayerInfo;
import ninja.trek.LayerManager;
import ninja.trek.Repal;
import ninja.trek.TextureManager;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import java.util.*;
public class LayerManagementUI {
    private final MinecraftClient client;
    private final int x;
    private final int y;
    private final int width;
    private ButtonWidget newLayerButton;
    private ButtonWidget deleteLayerButton;
    private ButtonWidget moveToLayerButton;
    private ButtonWidget cycleLayerButton;
    private TextFieldWidget layerNameField;
    private List<LayerInfo> layers;
    private int selectedLayerIndex = 0;
    private static final int BUTTON_HEIGHT = 20;
    private static final int BUTTON_SPACING = 4;
    private static final int FIELD_HEIGHT = 20;
    public LayerManagementUI(MinecraftClient client, int x, int y, int width) {
        this.client = client;
        this.x = x;
        this.y = y;
        this.width = width;
        this.layers = LayerManager.getInstance().getAllLayers();
    }
    public void init() {
        int currentY = y;
        int halfWidth = (width - BUTTON_SPACING) / 2;
        // Layer name field
        layerNameField = new TextFieldWidget(
                client.textRenderer,
                x,
                currentY,
                width,
                FIELD_HEIGHT,
                Text.empty()
        );
        layerNameField.setMaxLength(32);
        updateLayerNameField();
        currentY += FIELD_HEIGHT + BUTTON_SPACING;
        // New and Delete layer buttons
        newLayerButton = ButtonWidget.builder(Text.translatable("repal.layer.new"), this::onNewLayerClick)
                .dimensions(x, currentY, halfWidth, BUTTON_HEIGHT)
                .build();
        deleteLayerButton = ButtonWidget.builder(Text.translatable("repal.layer.delete"), this::onDeleteLayerClick)
                .dimensions(x + halfWidth + BUTTON_SPACING, currentY, halfWidth, BUTTON_HEIGHT)
                .build();
        currentY += BUTTON_HEIGHT + BUTTON_SPACING;
        // Move to layer and cycle layer buttons
        moveToLayerButton = ButtonWidget.builder(Text.translatable("repal.layer.move"), this::onMoveToLayerClick)
                .dimensions(x, currentY, halfWidth, BUTTON_HEIGHT)
                .build();
        cycleLayerButton = ButtonWidget.builder(Text.translatable("repal.layer.cycle"), this::onCycleLayerClick)
                .dimensions(x + halfWidth + BUTTON_SPACING, currentY, halfWidth, BUTTON_HEIGHT)
                .build();
        updateButtonStates();
    }
    private void updateLayerNameField() {
        if (!layers.isEmpty()) {
            LayerInfo currentLayer = layers.get(selectedLayerIndex);
            layerNameField.setText(currentLayer.getName());
            layerNameField.setPlaceholder(Text.translatable("repal.layer.name.placeholder"));
        }
    }
    private void updateButtonStates() {
        boolean hasLayers = !layers.isEmpty();
        boolean hasSelectedTextures = !TextureManager.getSelectedTextures().isEmpty();
        boolean canDeleteLayer = hasLayers && layers.size() > 1;
        deleteLayerButton.active = canDeleteLayer;
        moveToLayerButton.active = hasSelectedTextures && hasLayers;
        cycleLayerButton.active = hasLayers;
        layerNameField.setEditable(hasLayers);
    }
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        // Draw layer name field
        layerNameField.render(context, mouseX, mouseY, delta);
        // Draw buttons
        newLayerButton.render(context, mouseX, mouseY, delta);
        deleteLayerButton.render(context, mouseX, mouseY, delta);
        moveToLayerButton.render(context, mouseX, mouseY, delta);
        cycleLayerButton.render(context, mouseX, mouseY, delta);
        // Draw layer info
        if (!layers.isEmpty()) {
            LayerInfo currentLayer = layers.get(selectedLayerIndex);
            String info = String.format("%d/%d: %s (%d textures)",
                    selectedLayerIndex + 1,
                    layers.size(),
                    currentLayer.getName(),
                    currentLayer.getTextures().size()
            );
            context.drawTextWithShadow(
                    client.textRenderer,
                    info,
                    x,
                    y + FIELD_HEIGHT * 3 + BUTTON_SPACING * 4,
                    0xFFFFFF
            );
        }
    }
    private void onNewLayerClick(ButtonWidget button) {
        String name = "Layer " + (layers.size() + 1);
        LayerInfo newLayer = LayerManager.getInstance().createLayer(name);
        layers = LayerManager.getInstance().getAllLayers();
        selectedLayerIndex = layers.indexOf(newLayer);
        updateLayerNameField();
        updateButtonStates();
    }
    private void onDeleteLayerClick(ButtonWidget button) {
        if (layers.size() <= 1) return;
        LayerInfo layerToDelete = layers.get(selectedLayerIndex);
        LayerManager.getInstance().deleteLayer(layerToDelete.getId());
        layers = LayerManager.getInstance().getAllLayers();
        selectedLayerIndex = Math.min(selectedLayerIndex, layers.size() - 1);
        updateLayerNameField();
        updateButtonStates();
    }
    private void onMoveToLayerClick(ButtonWidget button) {
        Set<Identifier> selectedTextures = TextureManager.getSelectedTextures();
        if (selectedTextures.isEmpty() || layers.isEmpty()) return;
        LayerInfo targetLayer = layers.get(selectedLayerIndex);
        TextureManager.moveSelectedTexturesToLayer(targetLayer);
        updateButtonStates();
    }
    private void onCycleLayerClick(ButtonWidget button) {
        if (layers.isEmpty()) return;
        selectedLayerIndex = (selectedLayerIndex + 1) % layers.size();
        LayerManager.getInstance().setActiveLayer(layers.get(selectedLayerIndex).getId());
        updateLayerNameField();
        updateButtonStates();
    }
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (layerNameField.mouseClicked(mouseX, mouseY, button)) {
            return true;
        }
        return false;
    }
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (layerNameField.isFocused() && keyCode == 257) { // Enter key
            String newName = layerNameField.getText().trim();
            if (!newName.isEmpty() && !layers.isEmpty()) {
                LayerInfo currentLayer = layers.get(selectedLayerIndex);
                currentLayer.setName(newName);
                layerNameField.setFocused(false);
                return true;
            }
        }
        return layerNameField.keyPressed(keyCode, scanCode, modifiers);
    }
    public boolean charTyped(char chr, int modifiers) {
        return layerNameField.charTyped(chr, modifiers);
    }
    public List<ButtonWidget> getButtons() {
        return Arrays.asList(
                newLayerButton,
                deleteLayerButton,
                moveToLayerButton,
                cycleLayerButton
        );
    }
    public void tick() {
        layerNameField.tick();
    }
}
</file>

<file path="client/java/ninja/trek/config/RepalModMenu.java">
package ninja.trek.config;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import ninja.trek.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
public class RepalModMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> new MergedConfigScreen(parent);
    }
    public class MergedConfigScreen extends Screen {
        private final Screen parent;
        private Screen clothConfigScreen;
        private TextureComboBox textureSearch;
        private LayerManagementUI layerUI;
        private PresetManagementUI presetUI;
        private ButtonWidget processButton;
        private int previewScrollOffset = 0;
        private int columnsPerRow;
        private int currentScrollRow = 0;
        private ButtonWidget scrollUpButton;
        private ButtonWidget scrollDownButton;
        private List<Identifier> currentTextures;
        // Layout constants
        private static final int PREVIEW_SIZE = 64;
        private static final int PREVIEW_SPACING = 16;
        private static final int CONFIG_HEIGHT = 200;
        private static final int PREVIEWS_START_Y = CONFIG_HEIGHT + 20;
        private static final int SIDE_PANEL_WIDTH = 200;
        private static final int UI_SPACING = 10;
        public MergedConfigScreen(Screen parent) {
            super(Text.translatable("repal.config.title"));
            this.parent = parent;
        }
        @Override
        protected void init() {
            int mainWidth = width - SIDE_PANEL_WIDTH - UI_SPACING;
            // Initialize cloth config on the left side
            initializeConfigUI(0, 0, mainWidth);
            // Initialize layer management on the right side
            layerUI = new LayerManagementUI(client, width - SIDE_PANEL_WIDTH, 0, SIDE_PANEL_WIDTH);
            layerUI.init();
            // Initialize preset management below layer management
            presetUI = new PresetManagementUI(client, width - SIDE_PANEL_WIDTH, 180, SIDE_PANEL_WIDTH);
            presetUI.init();
            // Initialize texture search centered at the top
            textureSearch = new TextureComboBox(
                    client,
                    mainWidth / 2 - 100,
                    10,
                    200
            );
            addDrawableChild(textureSearch);
            // Add process button at the bottom of the right panel
            processButton = ButtonWidget.builder(
                            Text.translatable("repal.config.process"),
                            this::onProcessClick
                    )
                    .dimensions(width - SIDE_PANEL_WIDTH, height - 30, SIDE_PANEL_WIDTH, 20)
                    .build();
            addDrawableChild(processButton);
            // Initialize scroll buttons
            initializeScrollButtons(mainWidth);
            // Load textures
            TextureManager.loadTextures(client.getResourceManager());
            updateTextureList();
            // Add all UI elements to drawable children
            addDrawableChildren();
        }
        private void initializeConfigUI(int x, int y, int width) {
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(this)
                    .setTitle(Text.translatable("repal.config.title"))
                    .setSavingRunnable(() -> {
                        RepalConfig.save();
                        ProcessedTextureCache.clearCache();
                    })
                    .setTransparentBackground(true);
            ConfigCategory general = builder.getOrCreateCategory(
                    Text.translatable("repal.config.category.general")
            );
            ConfigEntryBuilder entryBuilder = builder.entryBuilder();
            // Add entries for the active layer
            LayerInfo activeLayer = LayerManager.getInstance().getActiveLayer();
            if (activeLayer != null) {
                // Contrast Slider
                var contrastEntry = entryBuilder.startIntSlider(
                                Text.translatable("repal.config.contrast"),
                                activeLayer.getContrast(),
                                Repal.MIN_ADJUSTMENT,
                                Repal.MAX_ADJUSTMENT
                        )
                        .setDefaultValue(0)
                        .setTooltip(Text.translatable("repal.tooltip.contrast"))
                        .setSaveConsumer(activeLayer::setContrast)
                        .build();
                general.addEntry(contrastEntry);
                // Saturation Slider
                var saturationEntry = entryBuilder.startIntSlider(
                                Text.translatable("repal.config.saturation"),
                                activeLayer.getSaturation(),
                                Repal.MIN_ADJUSTMENT,
                                Repal.MAX_ADJUSTMENT
                        )
                        .setDefaultValue(0)
                        .setTooltip(Text.translatable("repal.tooltip.saturation"))
                        .setSaveConsumer(activeLayer::setSaturation)
                        .build();
                general.addEntry(saturationEntry);
                // Palette Selection
                List<String> availablePaletteNames = RepalResourceReloadListener.getAvailablePalettes()
                        .stream()
                        .map(PaletteInfo::getName)
                        .collect(Collectors.toList());
                if (!availablePaletteNames.isEmpty()) {
                    var paletteEntry = entryBuilder.<String>startDropdownMenu(
                                    Text.translatable("repal.config.palette"),
                                    activeLayer.getPalette(),
                                    s -> s,
                                    s -> Text.literal(s)
                            )
                            .setSelections(availablePaletteNames)
                            .setDefaultValue(availablePaletteNames.get(0))
                            .setTooltip(Text.translatable("repal.tooltip.palette"))
                            .setSaveConsumer(activeLayer::setPalette)
                            .build();
                    general.addEntry(paletteEntry);
                }
            }
            clothConfigScreen = builder.build();
            clothConfigScreen.init(client, width, height);
        }
        private void initializeScrollButtons(int mainWidth) {
            int buttonWidth = 60;
            scrollUpButton = ButtonWidget.builder(
                            Text.literal("▲ Up"),
                            button -> {
                                if (currentScrollRow > 0) currentScrollRow--;
                                updateTextureList();
                            }
                    ).dimensions(mainWidth / 2 - buttonWidth - 5, PREVIEWS_START_Y - 20, buttonWidth, 20)
                    .build();
            scrollDownButton = ButtonWidget.builder(
                            Text.literal("Down ▼"),
                            button -> {
                                int maxRows = (int) Math.ceil((double) currentTextures.size() / columnsPerRow);
                                int visibleRows = (height - PREVIEWS_START_Y - 20) / (PREVIEW_SIZE + PREVIEW_SPACING);
                                if (currentScrollRow < maxRows - visibleRows) {
                                    currentScrollRow++;
                                    updateTextureList();
                                }
                            }
                    ).dimensions(mainWidth / 2 + 5, PREVIEWS_START_Y - 20, buttonWidth, 20)
                    .build();
            addDrawableChild(scrollUpButton);
            addDrawableChild(scrollDownButton);
        }
        private void addDrawableChildren() {
            // Add layer UI buttons
            for (ButtonWidget button : layerUI.getButtons()) {
                addDrawableChild(button);
            }
            // Add preset UI buttons
            for (ButtonWidget button : presetUI.getButtons()) {
                addDrawableChild(button);
            }
        }
        private void updateTextureList() {
            LayerInfo activeLayer = LayerManager.getInstance().getActiveLayer();
            currentTextures = activeLayer != null ?
                    new ArrayList<>(activeLayer.getTextures()) :
                    TextureManager.getAllBlockTextures();
        }
        private void onProcessClick(ButtonWidget button) {
            TextureProcessor.processAllTextures();
        }
        @Override
        public void render(DrawContext context, int mouseX, int mouseY, float delta) {
            super.render(context, mouseX, mouseY, delta);
            // Render cloth config screen
            if (clothConfigScreen != null) {
                clothConfigScreen.render(context, mouseX, mouseY, delta);
            }
            // Render texture search
            textureSearch.render(context, mouseX, mouseY, delta);
            // Render layer management UI
            layerUI.render(context, mouseX, mouseY, delta);
            // Render preset management UI
            presetUI.render(context, mouseX, mouseY, delta);
            // Render texture previews
            renderTexturePreviews(context, mouseX, mouseY);
            // Render process button
            processButton.render(context, mouseX, mouseY, delta);
        }
        private void renderTexturePreviews(DrawContext context, int mouseX, int mouseY) {
            // Implement texture preview rendering here
            // (Previous implementation remains largely the same)
        }
        @Override
        public boolean mouseClicked(double mouseX, double mouseY, int button) {
            if (layerUI.mouseClicked(mouseX, mouseY, button)) {
                return true;
            }
            if (presetUI.mouseClicked(mouseX, mouseY, button)) {
                return true;
            }
            if (clothConfigScreen != null && clothConfigScreen.mouseClicked(mouseX, mouseY, button)) {
                return true;
            }
            if (textureSearch.mouseClicked(mouseX, mouseY, button)) {
                return true;
            }
            return super.mouseClicked(mouseX, mouseY, button);
        }
        @Override
        public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
            if (layerUI.keyPressed(keyCode, scanCode, modifiers)) {
                return true;
            }
            if (presetUI.keyPressed(keyCode, scanCode, modifiers)) {
                return true;
            }
            if (clothConfigScreen != null && clothConfigScreen.keyPressed(keyCode, scanCode, modifiers)) {
                return true;
            }
            return super.keyPressed(keyCode, scanCode, modifiers);
        }
        @Override
        public boolean charTyped(char chr, int modifiers) {
            if (layerUI.charTyped(chr, modifiers)) {
                return true;
            }
            if (presetUI.charTyped(chr, modifiers)) {
                return true;
            }
            if (clothConfigScreen != null && clothConfigScreen.charTyped(chr, modifiers)) {
                return true;
            }
            return super.charTyped(chr, modifiers);
        }
        @Override
        public void tick() {
            super.tick();
            if (clothConfigScreen != null) {
                clothConfigScreen.tick();
            }
            layerUI.tick();
            presetUI.tick();
            textureSearch.tick();
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/TextureComboBox.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import ninja.trek.TextureManager;
import ninja.trek.Repal;
import java.util.ArrayList;
import java.util.List;
public class TextureComboBox extends TextFieldWidget {
    private boolean isDropdownVisible = false;
    private List<Identifier> suggestions = new ArrayList<>();
    private int selectedSuggestion = -1;
    private final int dropdownHeight = 120;
    private static final int SUGGESTION_HEIGHT = 12;
    private final MinecraftClient client;
    public TextureComboBox(MinecraftClient client, int x, int y, int width) {
        super(client.textRenderer, x, y, width, 20, Text.empty());
        this.client = client;
        setPlaceholder(Text.translatable("repal.search.textures"));
        setMaxLength(50);
        setEditable(true);
        setVisible(true);
        active = true;
        isDropdownVisible = false;
        suggestions = TextureManager.searchTextures("");
        setChangedListener(this::onTextChanged);
    }
    private void onTextChanged(String newText) {
        Repal.LOGGER.info("Text changed to: " + newText);
        updateSuggestions();
        selectedSuggestion = -1;
        isDropdownVisible = true;
    }
    @Override
    public boolean isActive() {
        return true;
    }
    @Override
    public boolean charTyped(char chr, int modifiers) {
        if (!isActive() || !isFocused()) {
            return false;
        }
        boolean handled = super.charTyped(chr, modifiers);
        if (handled) {
            updateSuggestions();
        }
        return handled;
    }
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (!isActive() || !isFocused()) {
            return false;
        }
        switch (keyCode) {
            case 265: // Up arrow
                if (selectedSuggestion > 0) {
                    selectedSuggestion--;
                    return true;
                }
                break;
            case 264: // Down arrow
                if (selectedSuggestion < suggestions.size() - 1) {
                    selectedSuggestion++;
                    return true;
                }
                break;
            case 257: // Enter
                if (selectedSuggestion >= 0 && selectedSuggestion < suggestions.size()) {
                    selectSuggestion(selectedSuggestion);
                    return true;
                }
                break;
        }
        boolean result = super.keyPressed(keyCode, scanCode, modifiers);
        if (result) {
            updateSuggestions();
        }
        return result;
    }
    private void updateSuggestions() {
        String currentText = getText();
        suggestions = TextureManager.searchTextures(currentText);
        isDropdownVisible = true;
    }
    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (!isActive()) {
            return false;
        }
        // Check if click is outside the textbox and dropdown
        boolean clickedOutside = mouseX < getX() || mouseX > getX() + getWidth() ||
                mouseY < getY() || mouseY > getY() + getHeight() +
                (isDropdownVisible ? Math.min(suggestions.size() * SUGGESTION_HEIGHT, dropdownHeight) : 0);
        if (clickedOutside) {
            isDropdownVisible = false;
            setFocused(false);
            return false;
        }
        // Check dropdown clicks
        if (isDropdownVisible && suggestions.size() > 0) {
            int relativeY = (int)(mouseY - (getY() + getHeight()));
            if (mouseX >= getX() && mouseX < getX() + getWidth() &&
                    relativeY >= 0 && relativeY < Math.min(suggestions.size() * SUGGESTION_HEIGHT, dropdownHeight)) {
                int index = relativeY / SUGGESTION_HEIGHT;
                if (index < suggestions.size()) {
                    selectSuggestion(index);
                    return true;
                }
            }
        }
        // Handle text field clicks
        boolean result = super.mouseClicked(mouseX, mouseY, button);
        if (result) {
            setFocused(true);
            isDropdownVisible = true;
            updateSuggestions();
        }
        return result;
    }
    private void selectSuggestion(int index) {
        if (index >= 0 && index < suggestions.size()) {
            Identifier selected = suggestions.get(index);
            String newText = selected.getPath().substring(
                    selected.getPath().lastIndexOf('/') + 1,
                    selected.getPath().lastIndexOf('.')
            );
            setText(newText);
            TextureManager.setCurrentPreviewTexture(selected);
            setFocused(false);
            isDropdownVisible = false;
        }
    }
    @Override
    public void renderWidget(DrawContext context, int mouseX, int mouseY, float delta) {
        if (!isVisible()) {
            return;
        }
        super.renderWidget(context, mouseX, mouseY, delta);
        if (isDropdownVisible && !suggestions.isEmpty()) {
            int x = getX();
            int y = getY() + getHeight();
            int width = this.width;
            // Draw dropdown background
            context.fill(x, y, x + width, y + Math.min(suggestions.size() * SUGGESTION_HEIGHT, dropdownHeight), 0xFF000000);
            // Draw suggestions
            int drawnCount = 0;
            for (int i = 0; i < suggestions.size() && drawnCount * SUGGESTION_HEIGHT < dropdownHeight; i++) {
                Identifier suggestion = suggestions.get(i);
                String displayText = suggestion.getPath().substring(
                        suggestion.getPath().lastIndexOf('/') + 1,
                        suggestion.getPath().lastIndexOf('.')
                );
                int suggestionY = y + (drawnCount * SUGGESTION_HEIGHT);
                int textColor = (i == selectedSuggestion) ? 0xFFFFFF00 : 0xFFFFFFFF;
                // Highlight if mouse is over
                if (mouseX >= x && mouseX < x + width &&
                        mouseY >= suggestionY && mouseY < suggestionY + SUGGESTION_HEIGHT) {
                    context.fill(x, suggestionY, x + width, suggestionY + SUGGESTION_HEIGHT, 0xFF404040);
                }
                // Highlight if selected
                else if (i == selectedSuggestion) {
                    context.fill(x, suggestionY, x + width, suggestionY + SUGGESTION_HEIGHT, 0xFF303030);
                }
                context.drawTextWithShadow(client.textRenderer,
                        displayText, x + 2, suggestionY + 2, textColor);
                drawnCount++;
            }
        }
    }
    @Override
    public void setFocused(boolean focused) {
        super.setFocused(focused);
        if (!focused) {
            isDropdownVisible = false;
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/ProcessedTextureCache.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
public class ProcessedTextureCache {
    private static class CacheKey {
        private final Identifier textureId;
        private final UUID layerId;
        public CacheKey(Identifier textureId, UUID layerId) {
            this.textureId = textureId;
            this.layerId = layerId;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            CacheKey cacheKey = (CacheKey) o;
            return textureId.equals(cacheKey.textureId) && layerId.equals(cacheKey.layerId);
        }
        @Override
        public int hashCode() {
            return 31 * textureId.hashCode() + layerId.hashCode();
        }
    }
    private static final ConcurrentHashMap<CacheKey, Identifier> processedTextureIds = new ConcurrentHashMap<>();
    private static final int MAX_CACHE_SIZE = 100; // Increased due to multiple layers
    public static Identifier getProcessedTexture(Identifier originalTexture, LayerInfo layer) {
        if (layer == null) {
            Repal.LOGGER.error("Attempted to get processed texture with null layer");
            return originalTexture;
        }
        CacheKey key = new CacheKey(originalTexture, layer.getId());
        return processedTextureIds.computeIfAbsent(key, k -> {
            Identifier processedId = Identifier.of(Repal.MOD_ID,
                    "processed/" + layer.getId() + "/" + k.textureId.getPath().replace('/', '_'));
            processTexture(k.textureId, processedId, layer);
            cleanCacheIfNeeded();
            return processedId;
        });
    }
    private static void processTexture(Identifier originalId, Identifier processedId, LayerInfo layer) {
        MinecraftClient client = MinecraftClient.getInstance();
        try {
            // Get the original texture resource
            var resource = client.getResourceManager()
                    .getResource(originalId)
                    .orElseThrow();
            // Read and process the image
            try (InputStream stream = resource.getInputStream()) {
                BufferedImage originalImage = ImageIO.read(stream);
                if (originalImage == null) {
                    throw new IllegalStateException("Failed to read image: " + originalId);
                }
                // Get layer-specific settings
                List<Color> layerPalette = RepalResourceReloadListener.getLayerPaletteColors(layer);
                BufferedImage processedImage = ImageProcessor.processImage(
                        originalImage,
                        layerPalette,
                        layer.getContrast(),
                        layer.getSaturation()
                );
                // Convert to NativeImage
                NativeImage nativeImage = new NativeImage(
                        processedImage.getWidth(),
                        processedImage.getHeight(),
                        false
                );
                // Copy processed image data to NativeImage
                for (int y = 0; y < processedImage.getHeight(); y++) {
                    for (int x = 0; x < processedImage.getWidth(); x++) {
                        int argb = processedImage.getRGB(x, y);
                        int a = (argb >> 24) & 0xFF;
                        int r = (argb >> 16) & 0xFF;
                        int g = (argb >> 8) & 0xFF;
                        int b = argb & 0xFF;
                        int abgr = (a << 24) | (b << 16) | (g << 8) | r;
                        nativeImage.setColor(x, y, abgr);
                    }
                }
                // Register the texture
                client.execute(() -> {
                    NativeImageBackedTexture texture = new NativeImageBackedTexture(nativeImage);
                    client.getTextureManager().registerTexture(processedId, texture);
                });
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to process texture data for " + originalId, e);
                throw e;
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process texture: " + originalId + " for layer: " + layer.getName(), e);
        }
    }
    private static void cleanCacheIfNeeded() {
        if (processedTextureIds.size() > MAX_CACHE_SIZE) {
            MinecraftClient client = MinecraftClient.getInstance();
            processedTextureIds.forEach((key, processedId) -> {
                client.getTextureManager().destroyTexture(processedId);
            });
            processedTextureIds.clear();
        }
    }
    public static void clearCache() {
        MinecraftClient client = MinecraftClient.getInstance();
        processedTextureIds.forEach((key, processedId) -> {
            client.getTextureManager().destroyTexture(processedId);
        });
        processedTextureIds.clear();
    }
    public static void clearLayerCache(UUID layerId) {
        MinecraftClient client = MinecraftClient.getInstance();
        processedTextureIds.entrySet().removeIf(entry -> {
            if (entry.getKey().layerId.equals(layerId)) {
                client.getTextureManager().destroyTexture(entry.getValue());
                return true;
            }
            return false;
        });
    }
}
</file>

<file path="client/java/ninja/trek/RepalClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import ninja.trek.Repal;
import java.io.IOException;
import java.io.InputStream;
public class RepalClient implements ClientModInitializer {
	private static NativeImageBackedTexture previewTexture;
	public static final Identifier PREVIEW_TEXTURE_ID = Identifier.of(Repal.MOD_ID, "preview");
	@Override
	public void onInitializeClient() {
		ClientLifecycleEvents.CLIENT_STARTED.register(client -> {
			initializePreviewTexture(client);
		});
		ClientLifecycleEvents.CLIENT_STOPPING.register(client -> {
			if (previewTexture != null) {
				client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
				previewTexture.close();
				previewTexture = null;
			}
		});
	}
	private void initializePreviewTexture(MinecraftClient client) {
		try {
			// Get the grass block texture resource
			var resource = client.getResourceManager()
					.getResource(Identifier.of("minecraft", "textures/block/grass_block_top.png"))
					.orElseThrow();
			// Read the texture directly as NativeImage
			try (InputStream stream = resource.getInputStream()) {
				NativeImage nativeImage = NativeImage.read(stream);
				previewTexture = new NativeImageBackedTexture(nativeImage);
				client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
			}
		} catch (Exception e) {
			Repal.LOGGER.error("Failed to initialize preview texture", e);
			e.printStackTrace();
			// Fallback to a solid color if loading fails
			try {
				NativeImage fallback = new NativeImage(16, 16, false);
				int grassColor = 0xFF7BAA3F; // Default grass green color
				for (int x = 0; x < 16; x++) {
					for (int y = 0; y < 16; y++) {
						fallback.setColor(x, y, grassColor);
					}
				}
				previewTexture = new NativeImageBackedTexture(fallback);
				client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
			} catch (Exception fallbackError) {
				Repal.LOGGER.error("Failed to create fallback texture", fallbackError);
			}
		}
	}
	/**
	 * Helper method to set a pixel color on a NativeImage.
	 *
	 * @param image The NativeImage instance.
	 * @param x The x coordinate.
	 * @param y The y coordinate.
	 * @param color The ARGB color value.
	 */
	private static void setColorArgb(NativeImage image, int x, int y, int color) {
		image.setColor(x, y, color);
	}
	public static void updatePreviewTexture(NativeImage newImage) {
		MinecraftClient client = MinecraftClient.getInstance();
		// Ensure we're on the main thread
		if (!client.isOnThread()) {
			client.execute(() -> updatePreviewTexture(newImage));
			return;
		}
		try {
			// Clean up old texture if it exists
			if (previewTexture != null) {
				previewTexture.close();
				client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
			}
			// Create and register new texture
			previewTexture = new NativeImageBackedTexture(newImage);
			client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
		} catch (Exception e) {
			Repal.LOGGER.error("Failed to update preview texture", e);
			e.printStackTrace();
		}
	}
}
</file>

<file path="client/java/ninja/trek/RepalDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class RepalDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/TextureManager.java">
package ninja.trek;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
public class TextureManager {
    private static final Pattern BLOCK_TEXTURE_PATTERN = Pattern.compile("textures/block/.*\\.png");
    private static final List<Identifier> allBlockTextures = new ArrayList<>();
    private static final Set<Identifier> selectedTextures = new HashSet<>();
    private static Identifier currentPreviewTexture = null;
    private static final Set<String> commonPrefixes = new HashSet<>(Arrays.asList(
            "stone", "dirt", "grass", "planks", "log", "leaves",
            "ore", "wool", "glass", "concrete", "terracotta"
    ));
    public static void loadTextures(ResourceManager resourceManager) {
        allBlockTextures.clear();
        allBlockTextures.addAll(
                resourceManager.findResources("textures/block", id ->
                                BLOCK_TEXTURE_PATTERN.matcher(id.getPath()).matches()
                        ).keySet().stream()
                        .sorted((a, b) -> {
                            String aName = a.getPath().substring(a.getPath().lastIndexOf('/') + 1);
                            String bName = b.getPath().substring(b.getPath().lastIndexOf('/') + 1);
                            boolean aHasPrefix = commonPrefixes.stream().anyMatch(prefix -> aName.startsWith(prefix));
                            boolean bHasPrefix = commonPrefixes.stream().anyMatch(prefix -> bName.startsWith(prefix));
                            if (aHasPrefix && !bHasPrefix) return -1;
                            if (!aHasPrefix && bHasPrefix) return 1;
                            return a.getPath().compareTo(b.getPath());
                        })
                        .collect(Collectors.toList())
        );
        // Update layer textures after reload
        LayerManager layerManager = LayerManager.getInstance();
        for (LayerInfo layer : layerManager.getAllLayers()) {
            // Remove any textures that no longer exist
            layer.getTextures().removeIf(texture -> !allBlockTextures.contains(texture));
        }
    }
    public static List<Identifier> getAllBlockTextures() {
        return new ArrayList<>(allBlockTextures);
    }
    public static List<Identifier> getUnassignedTextures() {
        Set<Identifier> assignedTextures = new HashSet<>();
        LayerManager.getInstance().getAllLayers().forEach(layer ->
                assignedTextures.addAll(layer.getTextures())
        );
        return allBlockTextures.stream()
                .filter(texture -> !assignedTextures.contains(texture))
                .collect(Collectors.toList());
    }
    public static List<Identifier> searchTextures(String query, LayerInfo layer) {
        List<Identifier> searchPool;
        if (layer != null) {
            // Search within the specified layer
            searchPool = new ArrayList<>(layer.getTextures());
        } else {
            // Search unassigned textures
            searchPool = getUnassignedTextures();
        }
        if (query == null || query.isEmpty()) {
            return searchPool.stream()
                    .limit(10)
                    .collect(Collectors.toList());
        }
        String lowerQuery = query.toLowerCase();
        return searchPool.stream()
                .filter(id -> {
                    String path = id.getPath();
                    String name = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
                    return name.toLowerCase().contains(lowerQuery);
                })
                .limit(10)
                .collect(Collectors.toList());
    }
    public static void toggleTextureSelection(Identifier texture) {
        if (selectedTextures.contains(texture)) {
            selectedTextures.remove(texture);
        } else {
            selectedTextures.add(texture);
        }
    }
    public static void clearSelection() {
        selectedTextures.clear();
    }
    public static Set<Identifier> getSelectedTextures() {
        return new HashSet<>(selectedTextures);
    }
    public static boolean isSelected(Identifier texture) {
        return selectedTextures.contains(texture);
    }
    public static Identifier getDefaultTexture() {
        return Identifier.of("minecraft", "textures/block/grass_block_side.png");
    }
    public static void setCurrentPreviewTexture(Identifier texture) {
        currentPreviewTexture = texture;
        // Clear any existing selection when setting a new preview
        selectedTextures.clear();
        // Add the new preview texture to selection
        if (texture != null) {
            selectedTextures.add(texture);
        }
    }
    public static Identifier getCurrentPreviewTexture() {
        if (currentPreviewTexture == null) {
            currentPreviewTexture = getDefaultTexture();
        }
        return currentPreviewTexture;
    }
    public static void moveSelectedTexturesToLayer(LayerInfo targetLayer) {
        if (targetLayer == null || selectedTextures.isEmpty()) {
            return;
        }
        // Remove selected textures from all other layers
        LayerManager.getInstance().getAllLayers().forEach(layer -> {
            if (!layer.getId().equals(targetLayer.getId())) {
                selectedTextures.forEach(layer::removeTexture);
            }
        });
        // Add to target layer
        targetLayer.addTextures(selectedTextures);
        // Clear selection after move
        clearSelection();
    }
}
</file>

<file path="client/java/ninja/trek/TextureProcessor.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import net.fabricmc.loader.api.FabricLoader;
import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.List;
import java.util.regex.Pattern;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
public class TextureProcessor {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final Pattern BLOCK_TEXTURE_PATTERN = Pattern.compile("textures/block/.*\\.png");
    private static final String[] COMMON_SUFFIXES = {
            "_top", "_bottom", "_side", "_front", "_back",
            "_base", "_overlay", "_particle", "_layer_1", "_layer_2",
            "", "_all", "_planks", "_log", "_stem",
            "_leaves", "_door_top", "_door_bottom"
    };
    public static void processAllTextures() {
        try {
            ResourceManager resourceManager = MinecraftClient.getInstance().getResourceManager();
            Path outputDir = FabricLoader.getInstance().getGameDir()
                    .resolve("resourcepacks")
                    .resolve(Repal.getPackName());
            // Create resource pack directory structure
            Files.createDirectories(outputDir.resolve("assets/minecraft/textures/block"));
            // Create pack.mcmeta
            createPackMcmeta(outputDir);
            // Process textures by layer
            LayerManager layerManager = LayerManager.getInstance();
            List<LayerInfo> layers = layerManager.getAllLayers();
            // Save layer configuration for reference
            saveLayerConfig(outputDir, layers);
            // Process each layer
            for (LayerInfo layer : layers) {
                processLayer(layer, resourceManager, outputDir);
            }
            // Process unassigned textures with default settings
            processUnassignedTextures(resourceManager, outputDir);
            Repal.LOGGER.info("Resource pack generation complete: {}", outputDir);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process textures", e);
        }
    }
    private static void createPackMcmeta(Path outputDir) throws IOException {
        JsonObject pack = new JsonObject();
        pack.addProperty("pack_format", 15); // Minecraft 1.21 pack format
        pack.addProperty("description", "Generated by Repal - " + Repal.getPackName());
        JsonObject root = new JsonObject();
        root.add("pack", pack);
        Files.write(
                outputDir.resolve("pack.mcmeta"),
                GSON.toJson(root).getBytes()
        );
    }
    private static void saveLayerConfig(Path outputDir, List<LayerInfo> layers) throws IOException {
        Path configDir = outputDir.resolve("repal_data");
        Files.createDirectories(configDir);
        JsonObject config = new JsonObject();
        for (LayerInfo layer : layers) {
            JsonObject layerConfig = new JsonObject();
            layerConfig.addProperty("name", layer.getName());
            layerConfig.addProperty("contrast", layer.getContrast());
            layerConfig.addProperty("saturation", layer.getSaturation());
            layerConfig.addProperty("palette", layer.getPalette());
            config.add(layer.getId().toString(), layerConfig);
        }
        Files.write(
                configDir.resolve("layers.json"),
                GSON.toJson(config).getBytes()
        );
    }
    private static void processLayer(LayerInfo layer, ResourceManager resourceManager, Path outputDir) {
        try {
            Repal.LOGGER.info("Processing layer '{}' with {} textures",
                    layer.getName(), layer.getTextures().size());
            Map<String, List<Identifier>> groups = groupTextures(layer.getTextures());
            List<Color> palette = RepalResourceReloadListener.getLayerPaletteColors(layer);
            // Process each texture group within the layer
            for (Map.Entry<String, List<Identifier>> entry : groups.entrySet()) {
                processTextureGroup(
                        entry.getKey(),
                        entry.getValue(),
                        resourceManager,
                        outputDir,
                        layer,
                        palette
                );
            }
            Repal.LOGGER.info("Layer '{}' processing complete", layer.getName());
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process layer '{}'", layer.getName(), e);
        }
    }
    private static void processUnassignedTextures(ResourceManager resourceManager, Path outputDir) {
        List<Identifier> unassigned = TextureManager.getUnassignedTextures();
        if (unassigned.isEmpty()) {
            return;
        }
        Repal.LOGGER.info("Processing {} unassigned textures with default settings", unassigned.size());
        Map<String, List<Identifier>> groups = groupTextures(unassigned);
        // Create a temporary layer with default settings
        LayerInfo defaultLayer = new LayerInfo("Default");
        List<Color> defaultPalette = RepalResourceReloadListener.getLayerPaletteColors(defaultLayer);
        // Process each group
        for (Map.Entry<String, List<Identifier>> entry : groups.entrySet()) {
            processTextureGroup(
                    entry.getKey(),
                    entry.getValue(),
                    resourceManager,
                    outputDir,
                    defaultLayer,
                    defaultPalette
            );
        }
    }
    private static Map<String, List<Identifier>> groupTextures(Collection<Identifier> textures) {
        Map<String, List<Identifier>> groups = new HashMap<>();
        // Initialize groups for all suffixes
        for (String suffix : COMMON_SUFFIXES) {
            groups.put(suffix, new ArrayList<>());
        }
        // Group textures by suffix
        for (Identifier identifier : textures) {
            String path = identifier.getPath();
            String filename = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
            String matchedSuffix = findMatchingSuffix(filename);
            groups.get(matchedSuffix).add(identifier);
        }
        // Remove empty groups
        groups.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return groups;
    }
    private static String findMatchingSuffix(String filename) {
        for (String suffix : COMMON_SUFFIXES) {
            if (filename.endsWith(suffix)) {
                return suffix;
            }
        }
        return ""; // Default group for no suffix match
    }
    private static void processTextureGroup(
            String suffix,
            List<Identifier> textures,
            ResourceManager resourceManager,
            Path outputDir,
            LayerInfo layer,
            List<Color> palette
    ) {
        try {
            Repal.LOGGER.info("Processing texture group '{}' in layer '{}' with {} textures",
                    suffix.isEmpty() ? "default" : suffix, layer.getName(), textures.size());
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    BufferedImage processed = ImageProcessor.processImage(
                            image,
                            palette,
                            layer.getContrast(),
                            layer.getSaturation()
                    );
                    // Save processed texture
                    String relativePath = id.getPath().substring("textures/".length());
                    Path outputPath = outputDir.resolve("assets/minecraft/textures").resolve(relativePath);
                    Files.createDirectories(outputPath.getParent());
                    ImageIO.write(processed, "png", outputPath.toFile());
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to process texture {} in layer {}", id, layer.getName(), e);
                }
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process texture group '{}' in layer '{}'",
                    suffix, layer.getName(), e);
        }
    }
}
</file>

<file path="client/resources/repal.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/config/RepalConfig.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import ninja.trek.LayerManager;
import ninja.trek.Repal;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
public class RepalConfig {
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();
    private static final Path CONFIG_PATH = FabricLoader.getInstance()
            .getConfigDir()
            .resolve("repal.json");
    private static RepalConfig INSTANCE;
    // Legacy fields (maintained for backward compatibility)
    private int preContrast = 0;
    private int preSaturation = 0;
    private String packName = "repal";
    private String selectedPalette = "builtin_1";
    // New field for layer data
    private String layerData;
    // Private constructor to enforce singleton
    private RepalConfig() {}
    public static RepalConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        if (Files.exists(CONFIG_PATH)) {
            try (Reader reader = Files.newBufferedReader(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(reader, RepalConfig.class);
                if (INSTANCE == null) {
                    INSTANCE = new RepalConfig();
                }
                // Import layer data if it exists
                if (INSTANCE.layerData != null && !INSTANCE.layerData.isEmpty()) {
                    LayerManager.getInstance().importFromJson(INSTANCE.layerData);
                }
                // Migrate legacy settings to default layer if needed
                if (INSTANCE.layerData == null || INSTANCE.layerData.isEmpty()) {
                    var defaultLayer = LayerManager.getInstance().getActiveLayer();
                    defaultLayer.setContrast(INSTANCE.preContrast);
                    defaultLayer.setSaturation(INSTANCE.preSaturation);
                    defaultLayer.setPalette(INSTANCE.selectedPalette);
                    save(); // Save the migrated data
                }
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to load config: ", e);
                INSTANCE = new RepalConfig();
            }
        } else {
            INSTANCE = new RepalConfig();
            save();
        }
    }
    public static void save() {
        try {
            Files.createDirectories(CONFIG_PATH.getParent());
            // Update layer data before saving
            if (INSTANCE != null) {
                INSTANCE.layerData = LayerManager.getInstance().exportToJson();
            }
            try (Writer writer = Files.newBufferedWriter(CONFIG_PATH)) {
                GSON.toJson(get(), writer);
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to save config: ", e);
        }
    }
    // Legacy getters (now pull from active layer)
    public int preContrast() {
        return LayerManager.getInstance().getActiveLayer().getContrast();
    }
    public int preSaturation() {
        return LayerManager.getInstance().getActiveLayer().getSaturation();
    }
    public String selectedPalette() {
        return LayerManager.getInstance().getActiveLayer().getPalette();
    }
    public String packName() {
        return packName;
    }
    // Legacy setters (now update active layer)
    public void setPreContrast(int value) {
        LayerManager.getInstance().getActiveLayer().setContrast(value);
        save();
    }
    public void setPreSaturation(int value) {
        LayerManager.getInstance().getActiveLayer().setSaturation(value);
        save();
    }
    public void setSelectedPalette(String name) {
        LayerManager.getInstance().getActiveLayer().setPalette(name);
        save();
    }
    public void setPackName(String name) {
        this.packName = name == null || name.trim().isEmpty() ? "repal" : name.trim();
        save();
    }
}
</file>

<file path="main/java/ninja/trek/ImageProcessor.java">
package ninja.trek;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.util.*;
public class ImageProcessor {
    // Cache for color mappings to improve performance when processing multiple textures
    private static final Map<Color, Color> colorMappingCache = new HashMap<>();
    public static BufferedImage processImage(BufferedImage input, List<Color> targetPalette, int contrast, int saturation) {
        if (targetPalette.isEmpty()) {
            Repal.LOGGER.info("empty pallette");
            return input;
        }
        BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), BufferedImage.TYPE_INT_ARGB);
        // Pre-process adjustments
        float contrastFactor = (100.0f + contrast) / 100.0f;
        float saturationFactor = (100.0f + saturation) / 100.0f;
        // Process each pixel
        for (int y = 0; y < input.getHeight(); y++) {
            for (int x = 0; x < input.getWidth(); x++) {
                Color inputColor = new Color(input.getRGB(x, y), true);
                // Skip fully transparent pixels
                if (inputColor.getAlpha() == 0) {
                    output.setRGB(x, y, inputColor.getRGB());
                    continue;
                }
                // Apply pre-processing
                Color adjustedColor = adjustColor(inputColor, contrastFactor, saturationFactor);
                // Find closest palette color
                Color mappedColor = colorMappingCache.computeIfAbsent(adjustedColor,
                        color -> findClosestPaletteColor(color, targetPalette));
                // Preserve original alpha
                Color finalColor = new Color(
                        mappedColor.getRed(),
                        mappedColor.getGreen(),
                        mappedColor.getBlue(),
                        inputColor.getAlpha()
                );
                output.setRGB(x, y, finalColor.getRGB());
            }
        }
        return output;
    }
    private static Color adjustColor(Color input, float contrastFactor, float saturationFactor) {
        float[] hsb = Color.RGBtoHSB(input.getRed(), input.getGreen(), input.getBlue(), null);
        // Adjust saturation
        hsb[1] = Math.max(0.0f, Math.min(1.0f, hsb[1] * saturationFactor));
        // Adjust contrast (using brightness)
        float adjustedBrightness = ((hsb[2] - 0.5f) * contrastFactor) + 0.5f;
        hsb[2] = Math.max(0.0f, Math.min(1.0f, adjustedBrightness));
        // Convert back to RGB
        int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
        return new Color(rgb);
    }
    private static Color findClosestPaletteColor(Color input, List<Color> palette) {
        Color closestColor = palette.get(0);
        double minDistance = Double.MAX_VALUE;
        for (Color paletteColor : palette) {
            double distance = calculateColorDistance(input, paletteColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = paletteColor;
            }
        }
        return closestColor;
    }
    private static double calculateColorDistance(Color c1, Color c2) {
        // Using CIE76 color difference formula
        // Convert RGB to Lab color space for better color comparison
        double[] lab1 = rgbToLab(c1);
        double[] lab2 = rgbToLab(c2);
        // Calculate Euclidean distance in Lab space
        double deltaL = lab1[0] - lab2[0];
        double deltaA = lab1[1] - lab2[1];
        double deltaB = lab1[2] - lab2[2];
        return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
    }
    private static double[] rgbToLab(Color color) {
        // RGB to XYZ
        double r = color.getRed() / 255.0;
        double g = color.getGreen() / 255.0;
        double b = color.getBlue() / 255.0;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        double x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
        double y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
        double z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
        // XYZ to Lab
        x /= 95.047;
        y /= 100.000;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1.0/3.0) : (7.787 * x) + 16.0/116.0;
        y = y > 0.008856 ? Math.pow(y, 1.0/3.0) : (7.787 * y) + 16.0/116.0;
        z = z > 0.008856 ? Math.pow(z, 1.0/3.0) : (7.787 * z) + 16.0/116.0;
        return new double[] {
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
        };
    }
    public static void clearCache() {
        colorMappingCache.clear();
    }
}
</file>

<file path="main/java/ninja/trek/LayerInfo.java">
package ninja.trek;
import com.google.gson.annotations.Expose;
import net.minecraft.util.Identifier;
import java.util.*;
public class LayerInfo {
    @Expose private final UUID id;
    @Expose private String name;
    @Expose private Set<Identifier> textures;
    @Expose private int contrast;
    @Expose private int saturation;
    @Expose private String palette;
    public LayerInfo(String name) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.textures = new HashSet<>();
        this.contrast = 0;
        this.saturation = 0;
        this.palette = "builtin_1";
    }
    // Getters
    public UUID getId() { return id; }
    public String getName() { return name; }
    public Set<Identifier> getTextures() { return new HashSet<>(textures); }
    public int getContrast() { return contrast; }
    public int getSaturation() { return saturation; }
    public String getPalette() { return palette; }
    // Setters
    public void setName(String name) { this.name = name; }
    public void setContrast(int contrast) {
        this.contrast = Math.min(Math.max(contrast, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
    }
    public void setSaturation(int saturation) {
        this.saturation = Math.min(Math.max(saturation, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
    }
    public void setPalette(String palette) { this.palette = palette; }
    // Texture management
    public void addTexture(Identifier texture) { textures.add(texture); }
    public void removeTexture(Identifier texture) { textures.remove(texture); }
    public void addTextures(Collection<Identifier> textures) { this.textures.addAll(textures); }
    public void clearTextures() { textures.clear(); }
}
</file>

<file path="main/java/ninja/trek/LayerManager.java">
package ninja.trek;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.util.Identifier;
import java.util.*;
public class LayerManager {
    private static final Gson GSON = new GsonBuilder()
            .excludeFieldsWithoutExposeAnnotation()
            .setPrettyPrinting()
            .create();
    private final Map<UUID, LayerInfo> layers;
    private UUID activeLayer;
    private static LayerManager INSTANCE;
    private LayerManager() {
        this.layers = new HashMap<>();
        // Create default layer
        LayerInfo defaultLayer = new LayerInfo("Default");
        this.layers.put(defaultLayer.getId(), defaultLayer);
        this.activeLayer = defaultLayer.getId();
    }
    public static LayerManager getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new LayerManager();
        }
        return INSTANCE;
    }
    // Layer operations
    public LayerInfo createLayer(String name) {
        LayerInfo layer = new LayerInfo(name);
        layers.put(layer.getId(), layer);
        return layer;
    }
    public void deleteLayer(UUID id) {
        if (layers.size() <= 1) {
            Repal.LOGGER.warn("Cannot delete the last remaining layer");
            return;
        }
        layers.remove(id);
        if (activeLayer.equals(id)) {
            activeLayer = layers.keySet().iterator().next();
        }
    }
    public void moveTexturesToLayer(Collection<Identifier> textures, UUID targetLayer) {
        LayerInfo layer = layers.get(targetLayer);
        if (layer != null) {
            // Remove textures from all other layers first
            for (LayerInfo otherLayer : layers.values()) {
                otherLayer.getTextures().removeAll(textures);
            }
            // Add to target layer
            layer.addTextures(textures);
        }
    }
    // Getters
    public LayerInfo getLayer(UUID id) {
        return layers.get(id);
    }
    public LayerInfo getActiveLayer() {
        return layers.get(activeLayer);
    }
    public List<LayerInfo> getAllLayers() {
        return new ArrayList<>(layers.values());
    }
    public void setActiveLayer(UUID id) {
        if (layers.containsKey(id)) {
            this.activeLayer = id;
        }
    }
    // Import/Export
    public String exportToJson() {
        return GSON.toJson(new ArrayList<>(layers.values()));
    }
    public void importFromJson(String json) {
        try {
            LayerInfo[] importedLayers = GSON.fromJson(json, LayerInfo[].class);
            layers.clear();
            for (LayerInfo layer : importedLayers) {
                layers.put(layer.getId(), layer);
            }
            if (layers.isEmpty()) {
                // Create default layer if import was empty
                LayerInfo defaultLayer = new LayerInfo("Default");
                layers.put(defaultLayer.getId(), defaultLayer);
                activeLayer = defaultLayer.getId();
            } else if (!layers.containsKey(activeLayer)) {
                // Set active layer to first available if current one was removed
                activeLayer = layers.keySet().iterator().next();
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to import layers", e);
            // Reset to default state
            layers.clear();
            LayerInfo defaultLayer = new LayerInfo("Default");
            layers.put(defaultLayer.getId(), defaultLayer);
            activeLayer = defaultLayer.getId();
        }
    }
    // Clear everything
    public void reset() {
        layers.clear();
        LayerInfo defaultLayer = new LayerInfo("Default");
        layers.put(defaultLayer.getId(), defaultLayer);
        activeLayer = defaultLayer.getId();
    }
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/PaletteInfo.java">
package ninja.trek;
import java.nio.file.Path;
public class PaletteInfo {
    private final String name;
    private final Path path;
    private final boolean isBuiltin;
    public PaletteInfo(String name, Path path, boolean isBuiltin) {
        this.name = name;
        this.path = path;
        this.isBuiltin = isBuiltin;
    }
    public String getName() { return name; }
    public Path getPath() { return path; }
    public boolean isBuiltin() { return isBuiltin; }
}
</file>

<file path="main/java/ninja/trek/Repal.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Repal implements ModInitializer {
	public static final String MOD_ID = "repal";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	// Identifiers for our palette resources
	public static final Identifier PALETTE_1 = Identifier.of(MOD_ID, "textures/palette/pal1.png");
	public static final Identifier PALETTE_2 = Identifier.of(MOD_ID, "textures/palette/pal2.png");
	// Constants for adjustment ranges
	public static final int MIN_ADJUSTMENT = -100;
	public static final int MAX_ADJUSTMENT = 100;
	private static int selectedPalette = 1;
	private static int preContrast = 0;
	private static int preSaturation = 0;
	private static String packName = "repal";
	@Override
	public void onInitialize() {
		LOGGER.info("Initializing Repal");
		// Register the resource reload listener
		ResourceManagerHelper.get(ResourceType.CLIENT_RESOURCES)
				.registerReloadListener(new RepalResourceReloadListener());
	}
	// Getter methods
	public static int getSelectedPalette() {
		return selectedPalette;
	}
	public static int getPreContrast() {
		return preContrast;
	}
	public static int getPreSaturation() {
		return preSaturation;
	}
	// Setter methods with validation
	public static void setSelectedPalette(int palette) {
		selectedPalette = (palette == 1 || palette == 2) ? palette : 1;
	}
	public static void setPreContrast(int contrast) {
		preContrast = Math.max(MIN_ADJUSTMENT, Math.min(MAX_ADJUSTMENT, contrast));
	}
	public static void setPreSaturation(int saturation) {
		preSaturation = Math.max(MIN_ADJUSTMENT, Math.min(MAX_ADJUSTMENT, saturation));
	}
	public static String getPackName() {
		return packName;
	}
	public static void setPackName(String name) {
		packName = (name == null || name.trim().isEmpty()) ? "repal" : name.trim();
	}
}
</file>

<file path="main/java/ninja/trek/RepalResourceReloadListener.java">
package ninja.trek;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.fabricmc.loader.api.FabricLoader;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import java.awt.Color;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import java.io.InputStream;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;
public class RepalResourceReloadListener implements SimpleSynchronousResourceReloadListener {
    private static final Map<String, List<Color>> paletteColors = new HashMap<>();
    private static final List<PaletteInfo> availablePalettes = new ArrayList<>();
    private static final Identifier PALETTE_1 = Identifier.of("repal", "textures/palette/pal1.png");
    private static final Identifier PALETTE_2 = Identifier.of("repal", "textures/palette/pal2.png");
    @Override
    public Identifier getFabricId() {
        return Identifier.of("repal", "palette_loader");
    }
    private void loadPalette(ResourceManager manager, Identifier paletteId, String paletteName) {
        try {
            manager.getResource(paletteId).ifPresent(resource -> {
                try (InputStream stream = resource.getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    Set<Color> uniqueColors = new HashSet<>();
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            Color color = new Color(image.getRGB(x, y), true);
                            if (color.getAlpha() == 255) {
                                uniqueColors.add(color);
                            }
                        }
                    }
                    List<Color> colors = new ArrayList<>(uniqueColors);
                    paletteColors.put(paletteName, colors);
                    availablePalettes.add(new PaletteInfo(paletteName, null, true));
                    Repal.LOGGER.info("Loaded {} colors from palette {}", uniqueColors.size(), paletteId);
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to load palette {}", paletteId, e);
                }
            });
        } catch (Exception e) {
            Repal.LOGGER.error("Error accessing palette {}", paletteId, e);
        }
    }
    private void loadCustomPalettes() {
        try {
            Path resourcePacksDir = FabricLoader.getInstance().getGameDir().resolve("resourcepacks");
            if (!Files.exists(resourcePacksDir)) {
                return;
            }
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(resourcePacksDir, "*.png")) {
                for (Path path : stream) {
                    String name = path.getFileName().toString();
                    name = name.substring(0, name.lastIndexOf('.'));
                    loadCustomPalette(path, name);
                }
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to load custom palettes", e);
        }
    }
    private void loadCustomPalette(Path path, String name) {
        try {
            BufferedImage image = ImageIO.read(path.toFile());
            Set<Color> uniqueColors = new HashSet<>();
            for (int y = 0; y < image.getHeight(); y++) {
                for (int x = 0; x < image.getWidth(); x++) {
                    Color color = new Color(image.getRGB(x, y), true);
                    if (color.getAlpha() == 255) {
                        uniqueColors.add(color);
                    }
                }
            }
            List<Color> colors = new ArrayList<>(uniqueColors);
            paletteColors.put(name, colors);
            availablePalettes.add(new PaletteInfo(name, path, false));
            Repal.LOGGER.info("Loaded custom palette {} with {} colors", name, colors.size());
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to load custom palette: {}", name, e);
        }
    }
    public static List<PaletteInfo> getAvailablePalettes() {
        return new ArrayList<>(availablePalettes);
    }
    public static List<Color> getPaletteColors(String paletteName) {
        return paletteColors.getOrDefault(paletteName, Collections.emptyList());
    }
    public static List<Color> getLayerPaletteColors(LayerInfo layer) {
        if (layer == null) {
            Repal.LOGGER.warn("Attempted to get palette colors for null layer");
            return Collections.emptyList();
        }
        String paletteName = layer.getPalette();
        List<Color> colors = paletteColors.get(paletteName);
        if (colors == null || colors.isEmpty()) {
            Repal.LOGGER.warn("No colors found for palette '{}' in layer '{}'", paletteName, layer.getName());
            // Fall back to default palette
            colors = paletteColors.getOrDefault("builtin_1", Collections.emptyList());
        }
        return colors;
    }
    @Override
    public void reload(ResourceManager manager) {
        paletteColors.clear();
        availablePalettes.clear();
        // Load built-in palettes
        loadPalette(manager, PALETTE_1, "builtin_1");
        loadPalette(manager, PALETTE_2, "builtin_2");
        // Load custom palettes
        loadCustomPalettes();
        // Validate all layer palettes after reload
        LayerManager layerManager = LayerManager.getInstance();
        for (LayerInfo layer : layerManager.getAllLayers()) {
            String currentPalette = layer.getPalette();
            if (!paletteColors.containsKey(currentPalette)) {
                Repal.LOGGER.warn("Invalid palette '{}' in layer '{}', resetting to default",
                        currentPalette, layer.getName());
                layer.setPalette("builtin_1");
            }
        }
        // Log loaded palettes
        Repal.LOGGER.info("Loaded {} palettes: {}",
                paletteColors.size(),
                String.join(", ", paletteColors.keySet()));
    }
}
</file>

<file path="main/resources/assets/repal/lang/en_us.json">
{
  "repal.config.title": "Repal Settings",
  "repal.config.contrast": "Pre-Contrast: %d",
  "repal.config.saturation": "Pre-Saturation: %d",
  "repal.config.palette": "Palette: %d",
  "repal.config.process": "Process Textures",
  "repal.preview.original": "Original",
  "repal.preview.processed": "Processed",
  "repal.status.processing": "Processing textures...",
  "repal.status.complete": "Resource pack generated: %s",
  "repal.status.failed": "Failed to generate resource pack",
  "repal.tooltip.contrast": "Adjusts contrast before palette mapping (-100 to 100)",
  "repal.tooltip.saturation": "Adjusts saturation before palette mapping (-100 to 100)",
  "repal.tooltip.palette": "Select palette to use for recoloring",
  "repal.tooltip.process": "Generate a new resource pack with recolored textures",
  "repal.search.textures": "Search textures...",
  "repal.search.label": "Preview Texture",

  "repal.layer.new": "New Layer",
  "repal.layer.delete": "Delete Layer",
  "repal.layer.move": "Move to Layer",
  "repal.layer.cycle": "Next Layer",
  "repal.layer.name.placeholder": "Enter layer name...",
  "repal.layer.default": "Default Layer",
  "repal.layer.count": "Layer %d/%d",
  "repal.layer.textures": "%d textures",
  "repal.layer.confirm.delete": "Delete layer '%s'?",
  "repal.layer.confirm.delete.desc": "This will move all textures to the default layer"
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "repal",
	"version": "${version}",
	"name": "Repal",
	"description": "A mod for recoloring Minecraft textures using custom palettes",
	"authors": [
		"trek"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/trek/repal"
	},
	"license": "MIT",
	"icon": "assets/repal/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.Repal"
		],
		"client": [
			"ninja.trek.RepalClient"
		],
		"modmenu": [
			"ninja.trek.config.RepalModMenu"
		],
		"fabric-datagen": [
			"ninja.trek.RepalDataGenerator"
		]
	},
	"mixins": [
		"repal.mixins.json",
		{
			"config": "repal.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.14.21",
		"minecraft": "~1.21",
		"java": ">=17",
		"fabric-api": "*",
		"cloth-config": ">=15.0.140",
		"modmenu": ">=11.0.3"
	},
	"custom": {
		"modmenu": {
			"links": {
				"modmenu.discord": "https://discord.gg/fabric",
				"modmenu.issues": "https://github.com/trek/repal/issues"
			}
		}
	}
}
</file>

<file path="main/resources/repal.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
