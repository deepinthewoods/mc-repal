This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-10T23:54:14.993Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/config/RepalModMenu.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/RepalClient.java
client/java/ninja/trek/RepalDataGenerator.java
client/java/ninja/trek/TextureProcessor.java
client/resources/repal.client.mixins.json
main/java/ninja/trek/config/RepalConfig.java
main/java/ninja/trek/ImageProcessor.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/java/ninja/trek/PaletteInfo.java
main/java/ninja/trek/Repal.java
main/java/ninja/trek/RepalResourceReloadListener.java
main/resources/assets/repal/lang/en_us.json
main/resources/fabric.mod.json
main/resources/repal.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/config/RepalModMenu.java">
package ninja.trek.config;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
import me.shedaniel.clothconfig2.gui.entries.DropdownBoxEntry;
import me.shedaniel.clothconfig2.gui.entries.IntegerSliderEntry;
import me.shedaniel.clothconfig2.gui.entries.StringListEntry;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import ninja.trek.Repal;
import ninja.trek.RepalClient;
import ninja.trek.ImageProcessor;
import ninja.trek.RepalResourceReloadListener;
import ninja.trek.PaletteInfo;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.List;
import java.util.stream.Collectors;
public class RepalModMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> new MergedConfigScreen(parent);
    }
    public static class MergedConfigScreen extends Screen {
        private final Screen parent;
        private Screen clothConfigScreen;
        private static final Identifier GRASS_PREVIEW = Identifier.of("minecraft", "textures/block/grass_block_side.png");
        private BufferedImage originalPreview;
        // Entry references
        private IntegerSliderEntry contrastEntry;
        private IntegerSliderEntry saturationEntry;
        private DropdownBoxEntry<String> paletteEntry;
        // Last known values
        private int lastContrast;
        private int lastSaturation;
        private String lastPalette;
        public MergedConfigScreen(Screen parent) {
            super(Text.translatable("repal.config.title"));
            this.parent = parent;
        }
        @Override
        protected void init() {
            // Build the Cloth Config UI
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(parent)
                    .setTitle(Text.translatable("repal.config.title"))
                    .setSavingRunnable(RepalConfig::save);
            ConfigCategory general = builder.getOrCreateCategory(
                    Text.translatable("repal.config.category.general")
            );
            ConfigEntryBuilder entryBuilder = builder.entryBuilder();
            // Pre-Contrast Slider
            var contrastEntry = entryBuilder.startIntSlider(
                            Text.translatable("repal.config.contrast"),
                            RepalConfig.get().preContrast(),
                            Repal.MIN_ADJUSTMENT,
                            Repal.MAX_ADJUSTMENT)
                    .setDefaultValue(0)
                    .setTooltip(Text.translatable("repal.tooltip.contrast"))
                    .setSaveConsumer(value -> RepalConfig.get().setPreContrast(value))
                    .build();
            general.addEntry(contrastEntry);
            // Pre-Saturation Slider
            var saturationEntry = entryBuilder.startIntSlider(
                            Text.translatable("repal.config.saturation"),
                            RepalConfig.get().preSaturation(),
                            Repal.MIN_ADJUSTMENT,
                            Repal.MAX_ADJUSTMENT)
                    .setDefaultValue(0)
                    .setTooltip(Text.translatable("repal.tooltip.saturation"))
                    .setSaveConsumer(value -> RepalConfig.get().setPreSaturation(value))
                    .build();
            general.addEntry(saturationEntry);
            // Find palettes
            List<PaletteInfo> palettes = RepalResourceReloadListener.getAvailablePalettes();
            Repal.LOGGER.info("Available palettes for menu: {}", palettes.stream()
                    .map(PaletteInfo::getName)
                    .collect(Collectors.joining(", ")));
// Create the dropdown
            var paletteEntry = entryBuilder.startStringDropdownMenu(
                            Text.translatable("repal.config.palette"),
                            RepalConfig.get().selectedPalette())
                    .setDefaultValue("builtin_1")
                    .setSelections(palettes.stream()
                            .map(PaletteInfo::getName)
                            .collect(Collectors.toSet()))
                    .setTooltip(Text.translatable("repal.tooltip.palette"))
                    .setSaveConsumer(value -> {
                        Repal.LOGGER.info("Selected palette: {}", value);
                        RepalConfig.get().setSelectedPalette(value);
                        RepalResourceReloadListener.setCurrentPalette(value);
                    })
                    .build();
            general.addEntry(paletteEntry);
            // Pack Name Field
            general.addEntry(entryBuilder.startStrField(
                            Text.translatable("repal.config.pack_name"),
                            RepalConfig.get().packName())
                    .setDefaultValue("repal")
                    .setTooltip(Text.translatable("repal.tooltip.pack_name"))
                    .setSaveConsumer(value -> RepalConfig.get().setPackName(value))
                    .build()
            );
            // Build the screen
            clothConfigScreen = builder.build();
            clothConfigScreen.init(client, width, height);
            // Store entry references after initialization
            this.contrastEntry = (IntegerSliderEntry) contrastEntry;
            this.saturationEntry = (IntegerSliderEntry) saturationEntry;
            this.paletteEntry =  paletteEntry;
            // Initialize the preview texture
            loadPreviewTexture();
            // Initialize last known values
            lastContrast = contrastEntry.getValue();
            lastSaturation = saturationEntry.getValue();
            lastPalette = paletteEntry.getValue();
        }
        private void loadPreviewTexture() {
            try {
                var resource = client.getResourceManager()
                        .getResource(GRASS_PREVIEW)
                        .orElseThrow();
                try (InputStream stream = resource.getInputStream()) {
                    BufferedImage originalImage = ImageIO.read(stream);
                    if (originalImage != null) {
                        originalPreview = originalImage;
                        updatePreview();
                    } else {
                        Repal.LOGGER.error("Failed to load preview texture - image is null");
                    }
                }
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to load preview texture", e);
            }
        }
        private NativeImage bufferedImageToNativeImage(BufferedImage image) {
            NativeImage nativeImage = new NativeImage(image.getWidth(), image.getHeight(), false);
            for (int y = 0; y < image.getHeight(); y++) {
                for (int x = 0; x < image.getWidth(); x++) {
                    int argb = image.getRGB(x, y);
                    int a = (argb >> 24) & 0xFF;
                    int r = (argb >> 16) & 0xFF;
                    int g = (argb >> 8) & 0xFF;
                    int b = argb & 0xFF;
                    int abgr = (a << 24) | (b << 16) | (g << 8) | r;
                    nativeImage.setColor(x, y, abgr);
                }
            }
            return nativeImage;
        }
        private void updatePreview() {
            if (originalPreview == null) return;
            try {
                BufferedImage processed = ImageProcessor.processImage(
                        originalPreview,
                        RepalResourceReloadListener.getCurrentPaletteColors(),
                        contrastEntry.getValue(),
                        saturationEntry.getValue()
                );
                NativeImage nativeImage = bufferedImageToNativeImage(processed);
                MinecraftClient.getInstance().execute(() -> {
                    RepalClient.updatePreviewTexture(nativeImage);
                });
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to update preview", e);
            }
        }
        @Override
        public void tick() {
            clothConfigScreen.tick();
            // Poll current values
            int currentContrast = contrastEntry.getValue();
            int currentSaturation = saturationEntry.getValue();
            String currentPalette = paletteEntry.getValue();
            // Check if any values have changed
            if (currentContrast != lastContrast ||
                    currentSaturation != lastSaturation ||
                    !currentPalette.equals(lastPalette)) {
                // Update RepalConfig with new values
                RepalConfig.get().setPreContrast(currentContrast);
                RepalConfig.get().setPreSaturation(currentSaturation);
                RepalConfig.get().setSelectedPalette(currentPalette);
                // Clear the ImageProcessor cache
                ImageProcessor.clearCache();
                // Force texture reload
                if (client != null && client.getTextureManager() != null) {
                    client.getTextureManager().destroyTexture(RepalClient.PREVIEW_TEXTURE_ID);
                }
                // Reload preview texture
                loadPreviewTexture();
                // Store new values
                lastContrast = currentContrast;
                lastSaturation = currentSaturation;
                lastPalette = currentPalette;
                Repal.LOGGER.info("Updated preview - Contrast: {}, Saturation: {}, Palette: {}",
                        currentContrast, currentSaturation, currentPalette);
            }
        }
        @Override
        public void render(DrawContext context, int mouseX, int mouseY, float delta) {
            // First, let the Cloth Config screen render its UI
            clothConfigScreen.render(context, mouseX, mouseY, delta);
            // Draw the preview area at the bottom
            int previewAreaHeight = 100;
            int yStart = height - previewAreaHeight + 10;
            // Draw the original texture preview on the left
            context.drawTexture(
                    GRASS_PREVIEW,
                    width / 4 - 32,
                    yStart,
                    0,
                    0.0f,
                    0.0f,
                    64,
                    64,
                    64,
                    64
            );
            // Draw the processed texture preview on the right
            context.drawTexture(
                    RepalClient.PREVIEW_TEXTURE_ID,
                    3 * width / 4 - 32,
                    yStart,
                    0,
                    0.0f,
                    0.0f,
                    64,
                    64,
                    64,
                    64
            );
            // Draw labels above the previews
            context.drawCenteredTextWithShadow(
                    textRenderer,
                    Text.translatable("repal.preview.original"),
                    width / 4,
                    yStart - 12,
                    0xFFFFFF
            );
            context.drawCenteredTextWithShadow(
                    textRenderer,
                    Text.translatable("repal.preview.processed"),
                    3 * width / 4,
                    yStart - 12,
                    0xFFFFFF
            );
        }
        @Override
        public void removed() {
            clothConfigScreen.removed();
        }
        @Override
        public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
            return clothConfigScreen.keyPressed(keyCode, scanCode, modifiers)
                    || super.keyPressed(keyCode, scanCode, modifiers);
        }
        @Override
        public boolean mouseClicked(double mouseX, double mouseY, int button) {
            return clothConfigScreen.mouseClicked(mouseX, mouseY, button)
                    || super.mouseClicked(mouseX, mouseY, button);
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/RepalClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import ninja.trek.Repal;
import java.io.IOException;
import java.io.InputStream;
public class RepalClient implements ClientModInitializer {
	private static NativeImageBackedTexture previewTexture;
	public static final Identifier PREVIEW_TEXTURE_ID = Identifier.of(Repal.MOD_ID, "preview");
	@Override
	public void onInitializeClient() {
		ClientLifecycleEvents.CLIENT_STARTED.register(client -> {
			initializePreviewTexture(client);
		});
		ClientLifecycleEvents.CLIENT_STOPPING.register(client -> {
			if (previewTexture != null) {
				client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
				previewTexture.close();
				previewTexture = null;
			}
		});
	}
	private void initializePreviewTexture(MinecraftClient client) {
		try {
			// Get the grass block texture resource
			var resource = client.getResourceManager()
					.getResource(Identifier.of("minecraft", "textures/block/grass_block_top.png"))
					.orElseThrow();
			// Read the texture directly as NativeImage
			try (InputStream stream = resource.getInputStream()) {
				NativeImage nativeImage = NativeImage.read(stream);
				previewTexture = new NativeImageBackedTexture(nativeImage);
				client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
			}
		} catch (Exception e) {
			Repal.LOGGER.error("Failed to initialize preview texture", e);
			e.printStackTrace();
			// Fallback to a solid color if loading fails
			try {
				NativeImage fallback = new NativeImage(16, 16, false);
				int grassColor = 0xFF7BAA3F; // Default grass green color
				for (int x = 0; x < 16; x++) {
					for (int y = 0; y < 16; y++) {
						fallback.setColor(x, y, grassColor);
					}
				}
				previewTexture = new NativeImageBackedTexture(fallback);
				client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
			} catch (Exception fallbackError) {
				Repal.LOGGER.error("Failed to create fallback texture", fallbackError);
			}
		}
	}
	/**
	 * Helper method to set a pixel color on a NativeImage.
	 *
	 * @param image The NativeImage instance.
	 * @param x The x coordinate.
	 * @param y The y coordinate.
	 * @param color The ARGB color value.
	 */
	private static void setColorArgb(NativeImage image, int x, int y, int color) {
		image.setColor(x, y, color);
	}
	public static void updatePreviewTexture(NativeImage newImage) {
		MinecraftClient client = MinecraftClient.getInstance();
		// Ensure we're on the main thread
		if (!client.isOnThread()) {
			client.execute(() -> updatePreviewTexture(newImage));
			return;
		}
		try {
			// Clean up old texture if it exists
			if (previewTexture != null) {
				previewTexture.close();
				client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
			}
			// Create and register new texture
			previewTexture = new NativeImageBackedTexture(newImage);
			client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
		} catch (Exception e) {
			Repal.LOGGER.error("Failed to update preview texture", e);
			e.printStackTrace();
		}
	}
}
</file>

<file path="client/java/ninja/trek/RepalDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class RepalDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/TextureProcessor.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import net.fabricmc.loader.api.FabricLoader;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
public class TextureProcessor {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final String[] COMMON_SUFFIXES = {
            "_top", "_bottom", "_side", "_front", "_back",
            "_base", "_overlay", "_particle", "_layer_1", "_layer_2",
            "", "_all", "_planks", "_log", "_stem",
            "_leaves", "_door_top", "_door_bottom"
    };
    private static final Pattern BLOCK_TEXTURE_PATTERN = Pattern.compile("textures/block/.*\\.png");
    public static void processAllTextures() {
        try {
            ResourceManager resourceManager = MinecraftClient.getInstance().getResourceManager();
            Path outputDir = FabricLoader.getInstance().getGameDir()
                    .resolve("resourcepacks")
                    .resolve(Repal.getPackName());
            // Create resource pack directory structure
            Files.createDirectories(outputDir.resolve("assets/minecraft/textures/block"));
            // Create pack.mcmeta
            createPackMcmeta(outputDir);
            // Group textures by suffix
            Map<String, List<Identifier>> textureGroups = groupTextures(resourceManager);
            // Process each group
            for (Map.Entry<String, List<Identifier>> entry : textureGroups.entrySet()) {
                processTextureGroup(entry.getKey(), entry.getValue(), resourceManager, outputDir);
            }
            Repal.LOGGER.info("Resource pack generation complete: {}", outputDir);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process textures", e);
        }
    }
    private static void createPackMcmeta(Path outputDir) throws IOException {
        JsonObject pack = new JsonObject();
        pack.addProperty("pack_format", 15); // Minecraft 1.21 pack format
        pack.addProperty("description", "Generated by Repal - " + Repal.getPackName());
        JsonObject root = new JsonObject();
        root.add("pack", pack);
        Files.write(
                outputDir.resolve("pack.mcmeta"),
                GSON.toJson(root).getBytes()
        );
    }
    private static Map<String, List<Identifier>> groupTextures(ResourceManager resourceManager) {
        Map<String, List<Identifier>> groups = new HashMap<>();
        // Initialize groups for all suffixes
        for (String suffix : COMMON_SUFFIXES) {
            groups.put(suffix, new ArrayList<>());
        }
        // Find all block textures
        resourceManager.findResources("textures/block", id ->
                BLOCK_TEXTURE_PATTERN.matcher(id.getPath()).matches()
        ).forEach((identifier, resource) -> {
            String path = identifier.getPath();
            String filename = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
            // Find matching suffix
            String matchedSuffix = findMatchingSuffix(filename);
            groups.get(matchedSuffix).add(identifier);
        });
        // Remove empty groups
        groups.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return groups;
    }
    private static String findMatchingSuffix(String filename) {
        for (String suffix : COMMON_SUFFIXES) {
            if (filename.endsWith(suffix)) {
                return suffix;
            }
        }
        return ""; // Default group for no suffix match
    }
    private static void processTextureGroup(
            String suffix,
            List<Identifier> textures,
            ResourceManager resourceManager,
            Path outputDir
    ) {
        try {
            Repal.LOGGER.info("Processing texture group '{}' with {} textures",
                    suffix.isEmpty() ? "default" : suffix, textures.size());
            Set<Integer> uniqueInputColors = new HashSet<>();
            int processedCount = 0;
            // First pass: collect all unique colors
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            uniqueInputColors.add(image.getRGB(x, y));
                        }
                    }
                }
            }
            // Process each texture
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    BufferedImage processed = ImageProcessor.processImage(
                            image,
                            RepalResourceReloadListener.getCurrentPaletteColors(),
                            Repal.getPreContrast(),
                            Repal.getPreSaturation()
                    );
                    // Save processed texture
                    String relativePath = id.getPath().substring("textures/".length());
                    Path outputPath = outputDir.resolve("assets/minecraft/textures").resolve(relativePath);
                    Files.createDirectories(outputPath.getParent());
                    ImageIO.write(processed, "png", outputPath.toFile());
                    processedCount++;
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to process texture {}", id, e);
                }
            }
            Repal.LOGGER.info("Group '{}' complete: {} unique input colors, {} textures processed",
                    suffix.isEmpty() ? "default" : suffix,
                    uniqueInputColors.size(),
                    processedCount);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process texture group '{}'", suffix, e);
        }
    }
}
</file>

<file path="client/resources/repal.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/config/RepalConfig.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import ninja.trek.PaletteInfo;
import ninja.trek.Repal;
import ninja.trek.RepalResourceReloadListener;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
public class RepalConfig {
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();
    private static final Path CONFIG_PATH = FabricLoader.getInstance()
            .getConfigDir()
            .resolve("repal.json");
    private static RepalConfig INSTANCE;
    private int preContrast = 0;
    private int preSaturation = 0;
    private String packName = "repal";
    private String selectedPalette = "builtin_1";
    public void setSelectedPalette(String name) {
        List<PaletteInfo> availablePalettes = RepalResourceReloadListener.getAvailablePalettes();
        boolean isValidPalette = availablePalettes.stream()
                .anyMatch(p -> p.getName().equals(name));
        if (isValidPalette) {
            this.selectedPalette = name;
            Repal.LOGGER.info("Set selected palette to: {}", name);
        } else {
            Repal.LOGGER.warn("Invalid palette name: {}. Defaulting to builtin_1", name);
            this.selectedPalette = "builtin_1";
        }
        save();
    }
    public String selectedPalette() {
        // Validate current selection
        List<PaletteInfo> availablePalettes = RepalResourceReloadListener.getAvailablePalettes();
        boolean isValidPalette = availablePalettes.stream()
                .anyMatch(p -> p.getName().equals(selectedPalette));
        if (!isValidPalette) {
            Repal.LOGGER.warn("Current palette {} is not valid. Defaulting to builtin_1", selectedPalette);
            selectedPalette = "builtin_1";
            save();
        }
        return selectedPalette;
    }
    // Private constructor to enforce singleton
    private RepalConfig() {}
    public static RepalConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        if (Files.exists(CONFIG_PATH)) {
            try (Reader reader = Files.newBufferedReader(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(reader, RepalConfig.class);
                if (INSTANCE == null) {
                    INSTANCE = new RepalConfig();
                }
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to load config: ", e);
                INSTANCE = new RepalConfig();
            }
        } else {
            INSTANCE = new RepalConfig();
            save();
        }
    }
    public static void save() {
        try {
            Files.createDirectories(CONFIG_PATH.getParent());
            try (Writer writer = Files.newBufferedWriter(CONFIG_PATH)) {
                GSON.toJson(get(), writer);
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to save config: ", e);
        }
    }
    // Getters
    public int preContrast() {
        return preContrast;
    }
    public int preSaturation() {
        return preSaturation;
    }
    public String packName() {
        return packName;
    }
    // Setters with validation
    public void setPreContrast(int value) {
        this.preContrast = Math.min(Math.max(value, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
        save();
    }
    public void setPreSaturation(int value) {
        Repal.LOGGER.info("set sat");
        this.preSaturation = Math.min(Math.max(value, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
        save();
    }
    public void setPackName(String name) {
        this.packName = name == null || name.trim().isEmpty() ? "repal" : name.trim();
        save();
    }
}
</file>

<file path="main/java/ninja/trek/ImageProcessor.java">
package ninja.trek;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.util.*;
public class ImageProcessor {
    // Cache for color mappings to improve performance when processing multiple textures
    private static final Map<Color, Color> colorMappingCache = new HashMap<>();
    public static BufferedImage processImage(BufferedImage input, List<Color> targetPalette, int contrast, int saturation) {
        if (targetPalette.isEmpty()) {
            Repal.LOGGER.info("empty pallette");
            return input;
        }
        BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), BufferedImage.TYPE_INT_ARGB);
        // Pre-process adjustments
        float contrastFactor = (100.0f + contrast) / 100.0f;
        float saturationFactor = (100.0f + saturation) / 100.0f;
        // Process each pixel
        for (int y = 0; y < input.getHeight(); y++) {
            for (int x = 0; x < input.getWidth(); x++) {
                Color inputColor = new Color(input.getRGB(x, y), true);
                // Skip fully transparent pixels
                if (inputColor.getAlpha() == 0) {
                    output.setRGB(x, y, inputColor.getRGB());
                    continue;
                }
                // Apply pre-processing
                Color adjustedColor = adjustColor(inputColor, contrastFactor, saturationFactor);
                // Find closest palette color
                Color mappedColor = colorMappingCache.computeIfAbsent(adjustedColor,
                        color -> findClosestPaletteColor(color, targetPalette));
                // Preserve original alpha
                Color finalColor = new Color(
                        mappedColor.getRed(),
                        mappedColor.getGreen(),
                        mappedColor.getBlue(),
                        inputColor.getAlpha()
                );
                output.setRGB(x, y, finalColor.getRGB());
            }
        }
        return output;
    }
    private static Color adjustColor(Color input, float contrastFactor, float saturationFactor) {
        float[] hsb = Color.RGBtoHSB(input.getRed(), input.getGreen(), input.getBlue(), null);
        // Adjust saturation
        hsb[1] = Math.max(0.0f, Math.min(1.0f, hsb[1] * saturationFactor));
        // Adjust contrast (using brightness)
        float adjustedBrightness = ((hsb[2] - 0.5f) * contrastFactor) + 0.5f;
        hsb[2] = Math.max(0.0f, Math.min(1.0f, adjustedBrightness));
        // Convert back to RGB
        int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
        return new Color(rgb);
    }
    private static Color findClosestPaletteColor(Color input, List<Color> palette) {
        Color closestColor = palette.get(0);
        double minDistance = Double.MAX_VALUE;
        for (Color paletteColor : palette) {
            double distance = calculateColorDistance(input, paletteColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = paletteColor;
            }
        }
        return closestColor;
    }
    private static double calculateColorDistance(Color c1, Color c2) {
        // Using CIE76 color difference formula
        // Convert RGB to Lab color space for better color comparison
        double[] lab1 = rgbToLab(c1);
        double[] lab2 = rgbToLab(c2);
        // Calculate Euclidean distance in Lab space
        double deltaL = lab1[0] - lab2[0];
        double deltaA = lab1[1] - lab2[1];
        double deltaB = lab1[2] - lab2[2];
        return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
    }
    private static double[] rgbToLab(Color color) {
        // RGB to XYZ
        double r = color.getRed() / 255.0;
        double g = color.getGreen() / 255.0;
        double b = color.getBlue() / 255.0;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        double x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
        double y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
        double z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
        // XYZ to Lab
        x /= 95.047;
        y /= 100.000;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1.0/3.0) : (7.787 * x) + 16.0/116.0;
        y = y > 0.008856 ? Math.pow(y, 1.0/3.0) : (7.787 * y) + 16.0/116.0;
        z = z > 0.008856 ? Math.pow(z, 1.0/3.0) : (7.787 * z) + 16.0/116.0;
        return new double[] {
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
        };
    }
    public static void clearCache() {
        colorMappingCache.clear();
    }
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/PaletteInfo.java">
package ninja.trek;
import java.nio.file.Path;
public class PaletteInfo {
    private final String name;
    private final Path path;
    private final boolean isBuiltin;
    public PaletteInfo(String name, Path path, boolean isBuiltin) {
        this.name = name;
        this.path = path;
        this.isBuiltin = isBuiltin;
    }
    public String getName() { return name; }
    public Path getPath() { return path; }
    public boolean isBuiltin() { return isBuiltin; }
}
</file>

<file path="main/java/ninja/trek/Repal.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Repal implements ModInitializer {
	public static final String MOD_ID = "repal";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	// Identifiers for our palette resources
	public static final Identifier PALETTE_1 = Identifier.of(MOD_ID, "textures/palette/pal1.png");
	public static final Identifier PALETTE_2 = Identifier.of(MOD_ID, "textures/palette/pal2.png");
	// Constants for adjustment ranges
	public static final int MIN_ADJUSTMENT = -100;
	public static final int MAX_ADJUSTMENT = 100;
	private static int selectedPalette = 1;
	private static int preContrast = 0;
	private static int preSaturation = 0;
	private static String packName = "repal";
	@Override
	public void onInitialize() {
		LOGGER.info("Initializing Repal");
		// Register the resource reload listener
		ResourceManagerHelper.get(ResourceType.CLIENT_RESOURCES)
				.registerReloadListener(new RepalResourceReloadListener());
	}
	// Getter methods
	public static int getSelectedPalette() {
		return selectedPalette;
	}
	public static int getPreContrast() {
		return preContrast;
	}
	public static int getPreSaturation() {
		return preSaturation;
	}
	// Setter methods with validation
	public static void setSelectedPalette(int palette) {
		selectedPalette = (palette == 1 || palette == 2) ? palette : 1;
	}
	public static void setPreContrast(int contrast) {
		preContrast = Math.max(MIN_ADJUSTMENT, Math.min(MAX_ADJUSTMENT, contrast));
	}
	public static void setPreSaturation(int saturation) {
		preSaturation = Math.max(MIN_ADJUSTMENT, Math.min(MAX_ADJUSTMENT, saturation));
	}
	public static String getPackName() {
		return packName;
	}
	public static void setPackName(String name) {
		packName = (name == null || name.trim().isEmpty()) ? "repal" : name.trim();
	}
}
</file>

<file path="main/java/ninja/trek/RepalResourceReloadListener.java">
package ninja.trek;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.fabricmc.loader.api.FabricLoader;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import java.awt.Color;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import java.io.InputStream;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;
public class RepalResourceReloadListener implements SimpleSynchronousResourceReloadListener {
    private static final Map<String, List<Color>> paletteColors = new HashMap<>();
    private static final List<PaletteInfo> availablePalettes = new ArrayList<>();
    private static String currentPalette = "builtin_1";
    private static final Identifier PALETTE_1 = Identifier.of("repal", "textures/palette/pal1.png");
    private static final Identifier PALETTE_2 = Identifier.of("repal", "textures/palette/pal2.png");
    @Override
    public Identifier getFabricId() {
        return Identifier.of("repal", "palette_loader");
    }
    @Override
    public void reload(ResourceManager manager) {
        paletteColors.clear();
        availablePalettes.clear();
        // Load built-in palettes
        loadPalette(manager, PALETTE_1, "pal1");
        loadPalette(manager, PALETTE_2, "pal2");
        // Load custom palettes
        loadCustomPalettes();
    }
    private void loadPalette(ResourceManager manager, Identifier paletteId, String paletteName) {
        try {
            manager.getResource(paletteId).ifPresent(resource -> {
                try (InputStream stream = resource.getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    Set<Color> uniqueColors = new HashSet<>();
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            Color color = new Color(image.getRGB(x, y), true);
                            if (color.getAlpha() == 255) { // Only add fully opaque colors
                                uniqueColors.add(color);
                            }
                        }
                    }
                    List<Color> colors = new ArrayList<>(uniqueColors);
                    paletteColors.put(paletteName, colors);
                    availablePalettes.add(new PaletteInfo(paletteName, null, true));
                    Repal.LOGGER.info("Loaded {} colors from palette {}", uniqueColors.size(), paletteId);
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to load palette {}", paletteId, e);
                }
            });
        } catch (Exception e) {
            Repal.LOGGER.error("Error accessing palette {}", paletteId, e);
        }
    }
    private void loadCustomPalettes() {
        try {
            Path resourcePacksDir = FabricLoader.getInstance().getGameDir().resolve("resourcepacks");
            Repal.LOGGER.info("Scanning for palettes in: {}", resourcePacksDir);
            if (!Files.exists(resourcePacksDir)) {
                Repal.LOGGER.warn("Resource packs directory does not exist: {}", resourcePacksDir);
                return;
            }
            // Log all files in the directory for debugging
            try (DirectoryStream<Path> allFiles = Files.newDirectoryStream(resourcePacksDir)) {
                Repal.LOGGER.info("Files in resourcepacks directory:");
                for (Path path : allFiles) {
                    Repal.LOGGER.info(" - {}", path.getFileName());
                }
            }
            // Now scan for PNGs
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(resourcePacksDir, "*.png")) {
                boolean foundAny = false;
                for (Path path : stream) {
                    String name = path.getFileName().toString();
                    name = name.substring(0, name.lastIndexOf('.'));
                    Repal.LOGGER.info("Found palette file: {}", path);
                    loadCustomPalette(path, name);
                    foundAny = true;
                }
                if (!foundAny) {
                    Repal.LOGGER.warn("No PNG files found in resourcepacks directory");
                }
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to load custom palettes", e);
            e.printStackTrace(); // Add full stack trace for debugging
        }
    }
    private void loadCustomPalette(Path path, String name) {
        try {
            Repal.LOGGER.info("Attempting to load palette: {} from {}", name, path);
            if (!Files.exists(path)) {
                Repal.LOGGER.error("Palette file does not exist: {}", path);
                return;
            }
            BufferedImage image = ImageIO.read(path.toFile());
            if (image == null) {
                Repal.LOGGER.error("Failed to read image from {}", path);
                return;
            }
            List<Color> colors = new ArrayList<>();
            Set<Color> uniqueColors = new HashSet<>();
            // Process image
            for (int y = 0; y < image.getHeight(); y++) {
                for (int x = 0; x < image.getWidth(); x++) {
                    Color color = new Color(image.getRGB(x, y), true);
                    if (color.getAlpha() == 255) {
                        uniqueColors.add(color);
                    }
                }
            }
            colors.addAll(uniqueColors);
            paletteColors.put(name, colors);
            availablePalettes.add(new PaletteInfo(name, path, false));
            Repal.LOGGER.info("Successfully loaded custom palette: {} with {} colors", name, colors.size());
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to load custom palette: {} - {}", name, e.getMessage());
            e.printStackTrace(); // Add full stack trace for debugging
        }
    }
    public static List<PaletteInfo> getAvailablePalettes() {
        return new ArrayList<>(availablePalettes);
    }
    public static List<Color> getCurrentPaletteColors() {
        return paletteColors.getOrDefault(currentPalette, new ArrayList<>());
    }
    public static void setCurrentPalette(String paletteName) {
        if (paletteColors.containsKey(paletteName)) {
            currentPalette = paletteName;
            ImageProcessor.clearCache();
        }
    }
}
</file>

<file path="main/resources/assets/repal/lang/en_us.json">
{
  "repal.config.title": "Repal Settings",
  "repal.config.contrast": "Pre-Contrast: %d",
  "repal.config.saturation": "Pre-Saturation: %d",
  "repal.config.palette": "Palette: %d",
  "repal.config.process": "Process Textures",
  "repal.preview.original": "Original",
  "repal.preview.processed": "Processed",
  "repal.status.processing": "Processing textures...",
  "repal.status.complete": "Resource pack generated: %s",
  "repal.status.failed": "Failed to generate resource pack",
  "repal.tooltip.contrast": "Adjusts contrast before palette mapping (-100 to 100)",
  "repal.tooltip.saturation": "Adjusts saturation before palette mapping (-100 to 100)",
  "repal.tooltip.palette": "Select palette to use for recoloring",
  "repal.tooltip.process": "Generate a new resource pack with recolored textures"
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "repal",
	"version": "${version}",
	"name": "Repal",
	"description": "A mod for recoloring Minecraft textures using custom palettes",
	"authors": [
		"trek"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/trek/repal"
	},
	"license": "MIT",
	"icon": "assets/repal/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.Repal"
		],
		"client": [
			"ninja.trek.RepalClient"
		],
		"modmenu": [
			"ninja.trek.config.RepalModMenu"
		],
		"fabric-datagen": [
			"ninja.trek.RepalDataGenerator"
		]
	},
	"mixins": [
		"repal.mixins.json",
		{
			"config": "repal.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.14.21",
		"minecraft": "~1.21",
		"java": ">=17",
		"fabric-api": "*",
		"cloth-config": ">=15.0.140",
		"modmenu": ">=11.0.3"
	},
	"custom": {
		"modmenu": {
			"links": {
				"modmenu.discord": "https://discord.gg/fabric",
				"modmenu.issues": "https://github.com/trek/repal/issues"
			}
		}
	}
}
</file>

<file path="main/resources/repal.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
