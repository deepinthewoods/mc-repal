This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-10T21:26:49.211Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/config/RepalConfigScreen.java
client/java/ninja/trek/config/RepalModMenu.java
client/java/ninja/trek/ImageProcessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/RepalClient.java
client/java/ninja/trek/RepalDataGenerator.java
client/java/ninja/trek/TextureProcessor.java
client/resources/repal.client.mixins.json
main/java/ninja/trek/config/RepalConfig.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/java/ninja/trek/Repal.java
main/java/ninja/trek/RepalResourceReloadListener.java
main/resources/assets/repal/lang/en_us.json
main/resources/fabric.mod.json
main/resources/repal.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/config/RepalConfigScreen.java">
package ninja.trek.config;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import net.minecraft.client.render.RenderLayer;
import ninja.trek.Repal;
import ninja.trek.RepalClient;
import ninja.trek.ImageProcessor;
import ninja.trek.RepalResourceReloadListener;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
public class RepalConfigScreen extends Screen {
    private static final Identifier GRASS_PREVIEW = Identifier.of("minecraft", "textures/block/grass_block_top.png");
    private final Screen parent;
    private SliderWidget contrastSlider;
    private SliderWidget saturationSlider;
    private ButtonWidget paletteButton;
    private TextFieldWidget packNameField;
    private ButtonWidget processButton;
    private BufferedImage originalPreview;
    public RepalConfigScreen(Screen parent) {
        super(Text.translatable("repal.config.title"));
        this.parent = parent;
    }
    @Override
    protected void init() {
        int centerX = width / 2;
        int startY = height / 4;
        // Load preview texture
        loadPreviewTexture();
    }
    private void loadPreviewTexture() {
        try {
            // Load original grass texture
            InputStream stream = client.getResourceManager()
                    .getResource(GRASS_PREVIEW)
                    .get()
                    .getInputStream();
            originalPreview = ImageIO.read(stream);
            updatePreview();
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to load preview texture", e);
        }
    }
    private void updatePreview() {
        if (originalPreview == null) return;
        try {
            // Process the preview image
            BufferedImage processed = ImageProcessor.processImage(
                    originalPreview,
                    RepalResourceReloadListener.getCurrentPaletteColors(),
                    Repal.getPreContrast(),
                    Repal.getPreSaturation()
            );
            // Convert BufferedImage to NativeImage
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            ImageIO.write(processed, "png", os);
            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
            NativeImage nativeImage = NativeImage.read(is);
            // Update the texture
            RepalClient.updatePreviewTexture(nativeImage);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to update preview", e);
        }
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        renderBackground(context, mouseX, mouseY, delta);
        // Draw the original texture
        context.drawTexture(
                GRASS_PREVIEW,         // texture identifier
                width / 4 - 32,        // x
                height / 2,            // y
                0,                     // z (depth)
                0.0f,                  // u coordinate start
                0.0f,                  // v coordinate start
                64,                    // width of the drawn quad
                64,                    // height of the drawn quad
                64,                    // texture width
                64                     // texture height
        );
        // Draw the processed texture
        context.drawTexture(
                RepalClient.PREVIEW_TEXTURE_ID, // texture identifier
                3 * width / 4 - 32,               // x
                height / 2,                       // y
                0,                                // z (depth)
                0.0f,                             // u coordinate start
                0.0f,                             // v coordinate start
                64,                               // width of the drawn quad
                64,                               // height of the drawn quad
                64,                               // texture width
                64                                // texture height
        );
        // Labels
        context.drawCenteredTextWithShadow(
                textRenderer,
                Text.translatable("repal.preview.original"),
                width / 4,
                height / 2 - 20,
                0xFFFFFF
        );
        context.drawCenteredTextWithShadow(
                textRenderer,
                Text.translatable("repal.preview.processed"),
                3 * width / 4,
                height / 2 - 20,
                0xFFFFFF
        );
        super.render(context, mouseX, mouseY, delta);
    }
    @Override
    public void removed() {
        super.removed();
    }
}
</file>

<file path="client/java/ninja/trek/config/RepalModMenu.java">
package ninja.trek.config;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
import net.minecraft.text.Text;
import ninja.trek.Repal;
public class RepalModMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> {
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(parent)
                    .setTitle(Text.translatable("repal.config.title"))
                    .setSavingRunnable(RepalConfig::save);
            ConfigCategory general = builder.getOrCreateCategory(
                    Text.translatable("repal.config.category.general")
            );
            ConfigEntryBuilder entryBuilder = builder.entryBuilder();
            // Pre-Contrast Slider
            general.addEntry(entryBuilder.startIntSlider(
                            Text.translatable("repal.config.contrast"),
                            RepalConfig.get().preContrast(),
                            Repal.MIN_ADJUSTMENT,
                            Repal.MAX_ADJUSTMENT)
                    .setDefaultValue(0)
                    .setTooltip(Text.translatable("repal.tooltip.contrast"))
                    .setSaveConsumer(value -> RepalConfig.get().setPreContrast(value))
                    .build()
            );
            // Pre-Saturation Slider
            general.addEntry(entryBuilder.startIntSlider(
                            Text.translatable("repal.config.saturation"),
                            RepalConfig.get().preSaturation(),
                            Repal.MIN_ADJUSTMENT,
                            Repal.MAX_ADJUSTMENT)
                    .setDefaultValue(0)
                    .setTooltip(Text.translatable("repal.tooltip.saturation"))
                    .setSaveConsumer(value -> RepalConfig.get().setPreSaturation(value))
                    .build()
            );
            // Palette Selection
            general.addEntry(entryBuilder.startIntField(
                            Text.translatable("repal.config.palette"),
                            RepalConfig.get().selectedPalette())
                    .setDefaultValue(1)
                    .setMin(1)
                    .setMax(2)
                    .setTooltip(Text.translatable("repal.tooltip.palette"))
                    .setSaveConsumer(value -> RepalConfig.get().setSelectedPalette(value))
                    .build()
            );
            // Pack Name Field
            general.addEntry(entryBuilder.startStrField(
                            Text.translatable("repal.config.pack_name"),
                            RepalConfig.get().packName())
                    .setDefaultValue("repal")
                    .setTooltip(Text.translatable("repal.tooltip.pack_name"))
                    .setSaveConsumer(value -> RepalConfig.get().setPackName(value))
                    .build()
            );
            return builder.build();
        };
    }
}
</file>

<file path="client/java/ninja/trek/ImageProcessor.java">
package ninja.trek;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.util.*;
public class ImageProcessor {
    // Cache for color mappings to improve performance when processing multiple textures
    private static final Map<Color, Color> colorMappingCache = new HashMap<>();
    public static BufferedImage processImage(BufferedImage input, List<Color> targetPalette, int contrast, int saturation) {
        if (targetPalette.isEmpty()) {
            return input;
        }
        BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), BufferedImage.TYPE_INT_ARGB);
        // Pre-process adjustments
        float contrastFactor = (100.0f + contrast) / 100.0f;
        float saturationFactor = (100.0f + saturation) / 100.0f;
        // Process each pixel
        for (int y = 0; y < input.getHeight(); y++) {
            for (int x = 0; x < input.getWidth(); x++) {
                Color inputColor = new Color(input.getRGB(x, y), true);
                // Skip fully transparent pixels
                if (inputColor.getAlpha() == 0) {
                    output.setRGB(x, y, inputColor.getRGB());
                    continue;
                }
                // Apply pre-processing
                Color adjustedColor = adjustColor(inputColor, contrastFactor, saturationFactor);
                // Find closest palette color
                Color mappedColor = colorMappingCache.computeIfAbsent(adjustedColor,
                        color -> findClosestPaletteColor(color, targetPalette));
                // Preserve original alpha
                Color finalColor = new Color(
                        mappedColor.getRed(),
                        mappedColor.getGreen(),
                        mappedColor.getBlue(),
                        inputColor.getAlpha()
                );
                output.setRGB(x, y, finalColor.getRGB());
            }
        }
        return output;
    }
    private static Color adjustColor(Color input, float contrastFactor, float saturationFactor) {
        float[] hsb = Color.RGBtoHSB(input.getRed(), input.getGreen(), input.getBlue(), null);
        // Adjust saturation
        hsb[1] = Math.max(0.0f, Math.min(1.0f, hsb[1] * saturationFactor));
        // Adjust contrast (using brightness)
        float adjustedBrightness = ((hsb[2] - 0.5f) * contrastFactor) + 0.5f;
        hsb[2] = Math.max(0.0f, Math.min(1.0f, adjustedBrightness));
        // Convert back to RGB
        int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
        return new Color(rgb);
    }
    private static Color findClosestPaletteColor(Color input, List<Color> palette) {
        Color closestColor = palette.get(0);
        double minDistance = Double.MAX_VALUE;
        for (Color paletteColor : palette) {
            double distance = calculateColorDistance(input, paletteColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = paletteColor;
            }
        }
        return closestColor;
    }
    private static double calculateColorDistance(Color c1, Color c2) {
        // Using CIE76 color difference formula
        // Convert RGB to Lab color space for better color comparison
        double[] lab1 = rgbToLab(c1);
        double[] lab2 = rgbToLab(c2);
        // Calculate Euclidean distance in Lab space
        double deltaL = lab1[0] - lab2[0];
        double deltaA = lab1[1] - lab2[1];
        double deltaB = lab1[2] - lab2[2];
        return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
    }
    private static double[] rgbToLab(Color color) {
        // RGB to XYZ
        double r = color.getRed() / 255.0;
        double g = color.getGreen() / 255.0;
        double b = color.getBlue() / 255.0;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        double x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
        double y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
        double z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
        // XYZ to Lab
        x /= 95.047;
        y /= 100.000;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1.0/3.0) : (7.787 * x) + 16.0/116.0;
        y = y > 0.008856 ? Math.pow(y, 1.0/3.0) : (7.787 * y) + 16.0/116.0;
        z = z > 0.008856 ? Math.pow(z, 1.0/3.0) : (7.787 * z) + 16.0/116.0;
        return new double[] {
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
        };
    }
    public static void clearCache() {
        colorMappingCache.clear();
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/RepalClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import ninja.trek.Repal;
public class RepalClient implements ClientModInitializer {
	private static NativeImageBackedTexture previewTexture;
	public static final Identifier PREVIEW_TEXTURE_ID = Identifier.of(Repal.MOD_ID, "preview");
	@Override
	public void onInitializeClient() {
		ClientLifecycleEvents.CLIENT_STARTED.register(client -> {
			initializePreviewTexture(client);
		});
		ClientLifecycleEvents.CLIENT_STOPPING.register(client -> {
			if (previewTexture != null) {
				client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
				previewTexture.close();
				previewTexture = null;
			}
		});
	}
	private void initializePreviewTexture(MinecraftClient client) {
		try {
			NativeImage image = new NativeImage(NativeImage.Format.RGBA, 16, 16, true);
			for (int x = 0; x < 16; x++) {
				for (int y = 0; y < 16; y++) {
					int color = (x + y) % 2 == 0 ? 0xFF808080 : 0xFFCCCCCC;
					setColorArgb(image, x, y, color);
				}
			}
			previewTexture = new NativeImageBackedTexture(image);
			client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
		} catch (Exception e) {
			Repal.LOGGER.error("Failed to initialize preview texture", e);
		}
	}
	/**
	 * Helper method to set a pixel color on a NativeImage.
	 *
	 * @param image The NativeImage instance.
	 * @param x The x coordinate.
	 * @param y The y coordinate.
	 * @param color The ARGB color value.
	 */
	private static void setColorArgb(NativeImage image, int x, int y, int color) {
		image.setColor(x, y, color);
	}
	public static void updatePreviewTexture(NativeImage newImage) {
		MinecraftClient client = MinecraftClient.getInstance();
		if (previewTexture != null) {
			client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
			previewTexture.close();
		}
		previewTexture = new NativeImageBackedTexture(newImage);
		client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
	}
}
</file>

<file path="client/java/ninja/trek/RepalDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class RepalDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/TextureProcessor.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import net.fabricmc.loader.api.FabricLoader;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
public class TextureProcessor {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final String[] COMMON_SUFFIXES = {
            "_top", "_bottom", "_side", "_front", "_back",
            "_base", "_overlay", "_particle", "_layer_1", "_layer_2",
            "", "_all", "_planks", "_log", "_stem",
            "_leaves", "_door_top", "_door_bottom"
    };
    private static final Pattern BLOCK_TEXTURE_PATTERN = Pattern.compile("textures/block/.*\\.png");
    public static void processAllTextures() {
        try {
            ResourceManager resourceManager = MinecraftClient.getInstance().getResourceManager();
            Path outputDir = FabricLoader.getInstance().getGameDir()
                    .resolve("resourcepacks")
                    .resolve(Repal.getPackName());
            // Create resource pack directory structure
            Files.createDirectories(outputDir.resolve("assets/minecraft/textures/block"));
            // Create pack.mcmeta
            createPackMcmeta(outputDir);
            // Group textures by suffix
            Map<String, List<Identifier>> textureGroups = groupTextures(resourceManager);
            // Process each group
            for (Map.Entry<String, List<Identifier>> entry : textureGroups.entrySet()) {
                processTextureGroup(entry.getKey(), entry.getValue(), resourceManager, outputDir);
            }
            Repal.LOGGER.info("Resource pack generation complete: {}", outputDir);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process textures", e);
        }
    }
    private static void createPackMcmeta(Path outputDir) throws IOException {
        JsonObject pack = new JsonObject();
        pack.addProperty("pack_format", 15); // Minecraft 1.21 pack format
        pack.addProperty("description", "Generated by Repal - " + Repal.getPackName());
        JsonObject root = new JsonObject();
        root.add("pack", pack);
        Files.write(
                outputDir.resolve("pack.mcmeta"),
                GSON.toJson(root).getBytes()
        );
    }
    private static Map<String, List<Identifier>> groupTextures(ResourceManager resourceManager) {
        Map<String, List<Identifier>> groups = new HashMap<>();
        // Initialize groups for all suffixes
        for (String suffix : COMMON_SUFFIXES) {
            groups.put(suffix, new ArrayList<>());
        }
        // Find all block textures
        resourceManager.findResources("textures/block", id ->
                BLOCK_TEXTURE_PATTERN.matcher(id.getPath()).matches()
        ).forEach((identifier, resource) -> {
            String path = identifier.getPath();
            String filename = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
            // Find matching suffix
            String matchedSuffix = findMatchingSuffix(filename);
            groups.get(matchedSuffix).add(identifier);
        });
        // Remove empty groups
        groups.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return groups;
    }
    private static String findMatchingSuffix(String filename) {
        for (String suffix : COMMON_SUFFIXES) {
            if (filename.endsWith(suffix)) {
                return suffix;
            }
        }
        return ""; // Default group for no suffix match
    }
    private static void processTextureGroup(
            String suffix,
            List<Identifier> textures,
            ResourceManager resourceManager,
            Path outputDir
    ) {
        try {
            Repal.LOGGER.info("Processing texture group '{}' with {} textures",
                    suffix.isEmpty() ? "default" : suffix, textures.size());
            Set<Integer> uniqueInputColors = new HashSet<>();
            int processedCount = 0;
            // First pass: collect all unique colors
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            uniqueInputColors.add(image.getRGB(x, y));
                        }
                    }
                }
            }
            // Process each texture
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    BufferedImage processed = ImageProcessor.processImage(
                            image,
                            RepalResourceReloadListener.getCurrentPaletteColors(),
                            Repal.getPreContrast(),
                            Repal.getPreSaturation()
                    );
                    // Save processed texture
                    String relativePath = id.getPath().substring("textures/".length());
                    Path outputPath = outputDir.resolve("assets/minecraft/textures").resolve(relativePath);
                    Files.createDirectories(outputPath.getParent());
                    ImageIO.write(processed, "png", outputPath.toFile());
                    processedCount++;
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to process texture {}", id, e);
                }
            }
            Repal.LOGGER.info("Group '{}' complete: {} unique input colors, {} textures processed",
                    suffix.isEmpty() ? "default" : suffix,
                    uniqueInputColors.size(),
                    processedCount);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process texture group '{}'", suffix, e);
        }
    }
}
</file>

<file path="client/resources/repal.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/config/RepalConfig.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import ninja.trek.Repal;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
public class RepalConfig {
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();
    private static final Path CONFIG_PATH = FabricLoader.getInstance()
            .getConfigDir()
            .resolve("repal.json");
    private static RepalConfig INSTANCE;
    private int preContrast = 0;
    private int preSaturation = 0;
    private int selectedPalette = 1;
    private String packName = "repal";
    // Private constructor to enforce singleton
    private RepalConfig() {}
    public static RepalConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        if (Files.exists(CONFIG_PATH)) {
            try (Reader reader = Files.newBufferedReader(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(reader, RepalConfig.class);
                if (INSTANCE == null) {
                    INSTANCE = new RepalConfig();
                }
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to load config: ", e);
                INSTANCE = new RepalConfig();
            }
        } else {
            INSTANCE = new RepalConfig();
            save();
        }
    }
    public static void save() {
        try {
            Files.createDirectories(CONFIG_PATH.getParent());
            try (Writer writer = Files.newBufferedWriter(CONFIG_PATH)) {
                GSON.toJson(get(), writer);
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to save config: ", e);
        }
    }
    // Getters
    public int preContrast() {
        return preContrast;
    }
    public int preSaturation() {
        return preSaturation;
    }
    public int selectedPalette() {
        return selectedPalette;
    }
    public String packName() {
        return packName;
    }
    // Setters with validation
    public void setPreContrast(int value) {
        this.preContrast = Math.min(Math.max(value, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
        save();
    }
    public void setPreSaturation(int value) {
        this.preSaturation = Math.min(Math.max(value, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
        save();
    }
    public void setSelectedPalette(int value) {
        this.selectedPalette = (value == 1 || value == 2) ? value : 1;
        save();
    }
    public void setPackName(String name) {
        this.packName = name == null || name.trim().isEmpty() ? "repal" : name.trim();
        save();
    }
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/Repal.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ninja.trek.config.RepalConfig;
public class Repal implements ModInitializer {
	public static final String MOD_ID = "repal";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	// Identifiers for our palette resources
	public static final Identifier PALETTE_1 = Identifier.of(MOD_ID, "textures/palette/pal1.png");
	public static final Identifier PALETTE_2 = Identifier.of(MOD_ID, "textures/palette/pal2.png");
	// Settings constants
	public static final int MIN_ADJUSTMENT = -100;
	public static final int MAX_ADJUSTMENT = 100;
	public static final int DEFAULT_ADJUSTMENT = 0;
	@Override
	public void onInitialize() {
		LOGGER.info("Initializing Repal - Texture Recoloring Mod");
		// Load config
		RepalConfig.load();
		// Register resource reload listener
		ResourceManagerHelper.get(ResourceType.CLIENT_RESOURCES)
				.registerReloadListener(new RepalResourceReloadListener());
	}
	// Static access methods that use the config
	public static int getPreContrast() {
		return RepalConfig.get().preContrast();
	}
	public static int getPreSaturation() {
		return RepalConfig.get().preSaturation();
	}
	public static int getSelectedPalette() {
		return RepalConfig.get().selectedPalette();
	}
	public static String getPackName() {
		return RepalConfig.get().packName();
	}
	public static void setPreContrast(int value) {
		RepalConfig.get().setPreContrast(value);
	}
	public static void setPreSaturation(int value) {
		RepalConfig.get().setPreSaturation(value);
	}
	public static void setSelectedPalette(int value) {
		RepalConfig.get().setSelectedPalette(value);
	}
	public static void setPackName(String name) {
		RepalConfig.get().setPackName(name);
	}
}
</file>

<file path="main/java/ninja/trek/RepalResourceReloadListener.java">
package ninja.trek;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.awt.Color;
public class RepalResourceReloadListener implements SimpleSynchronousResourceReloadListener {
    private static List<Color> palette1Colors = new ArrayList<>();
    private static List<Color> palette2Colors = new ArrayList<>();
    @Override
    public void reload(ResourceManager manager) {
        // Load both palettes
        loadPalette(manager, Repal.PALETTE_1, palette1Colors);
        loadPalette(manager, Repal.PALETTE_2, palette2Colors);
    }
    private void loadPalette(ResourceManager manager, Identifier paletteId, List<Color> colorList) {
        colorList.clear();
        try {
            manager.getResource(paletteId).ifPresent(resource -> {
                try (InputStream stream = resource.getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    Set<Color> uniqueColors = new HashSet<>();
                    // Scan every pixel in the image
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            Color color = new Color(image.getRGB(x, y), true);
                            // Only add fully opaque colors or fully transparent
                            if (color.getAlpha() == 255 || color.getAlpha() == 0) {
                                uniqueColors.add(color);
                            }
                        }
                    }
                    colorList.addAll(uniqueColors);
                    Repal.LOGGER.info("Loaded {} colors from palette {}", uniqueColors.size(), paletteId);
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to load palette {}: {}", paletteId, e.getMessage());
                }
            });
        } catch (Exception e) {
            Repal.LOGGER.error("Error accessing palette {}: {}", paletteId, e.getMessage());
        }
    }
    // Getters for the palette colors
    public static List<Color> getPalette1Colors() {
        return new ArrayList<>(palette1Colors);
    }
    public static List<Color> getPalette2Colors() {
        return new ArrayList<>(palette2Colors);
    }
    // Get currently selected palette colors
    public static List<Color> getCurrentPaletteColors() {
        return Repal.getSelectedPalette() == 1 ? getPalette1Colors() : getPalette2Colors();
    }
    @Override
    public Identifier getFabricId() {
        return Identifier.of(Repal.MOD_ID, "textures");
    }
}
</file>

<file path="main/resources/assets/repal/lang/en_us.json">
// assets/repal/lang/en_us.json
{
  "repal.config.title": "Repal Settings",
  "repal.config.contrast": "Pre-Contrast: %d",
  "repal.config.saturation": "Pre-Saturation: %d",
  "repal.config.palette": "Palette: %d",
  "repal.config.process": "Process Textures",
  "repal.preview.original": "Original",
  "repal.preview.processed": "Processed",
  "repal.status.processing": "Processing textures...",
  "repal.status.complete": "Resource pack generated: %s",
  "repal.status.failed": "Failed to generate resource pack",
  "repal.tooltip.contrast": "Adjusts contrast before palette mapping (-100 to 100)",
  "repal.tooltip.saturation": "Adjusts saturation before palette mapping (-100 to 100)",
  "repal.tooltip.palette": "Select palette to use for recoloring",
  "repal.tooltip.process": "Generate a new resource pack with recolored textures"
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "repal",
	"version": "${version}",
	"name": "Repal",
	"description": "A mod for recoloring Minecraft textures using custom palettes",
	"authors": [
		"trek"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/trek/repal"
	},
	"license": "MIT",
	"icon": "assets/repal/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.Repal"
		],
		"client": [
			"ninja.trek.RepalClient"
		],
		"modmenu": [
			"ninja.trek.config.RepalModMenu"
		],
		"fabric-datagen": [
			"ninja.trek.RepalDataGenerator"
		]
	},
	"mixins": [
		"repal.mixins.json",
		{
			"config": "repal.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.14.21",
		"minecraft": "~1.21",
		"java": ">=17",
		"fabric-api": "*",
		"cloth-config": ">=15.0.140",
		"modmenu": ">=11.0.3"
	},
	"custom": {
		"modmenu": {
			"links": {
				"modmenu.discord": "https://discord.gg/fabric",
				"modmenu.issues": "https://github.com/trek/repal/issues"
			}
		}
	}
}
</file>

<file path="main/resources/repal.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
