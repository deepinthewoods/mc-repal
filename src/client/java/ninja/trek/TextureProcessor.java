package ninja.trek;

import net.minecraft.client.MinecraftClient;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import net.fabricmc.loader.api.FabricLoader;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;

public class TextureProcessor {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final String[] COMMON_SUFFIXES = {
            "_top", "_bottom", "_side", "_front", "_back",
            "_base", "_overlay", "_particle", "_layer_1", "_layer_2",
            "", "_all", "_planks", "_log", "_stem",
            "_leaves", "_door_top", "_door_bottom"
    };

    private static final Pattern BLOCK_TEXTURE_PATTERN = Pattern.compile("textures/block/.*\\.png");

    public static void processAllTextures() {
        try {
            ResourceManager resourceManager = MinecraftClient.getInstance().getResourceManager();
            Path outputDir = FabricLoader.getInstance().getGameDir()
                    .resolve("resourcepacks")
                    .resolve(Repal.getPackName());

            // Create resource pack directory structure
            Files.createDirectories(outputDir.resolve("assets/minecraft/textures/block"));

            // Create pack.mcmeta
            createPackMcmeta(outputDir);

            // Group textures by suffix
            Map<String, List<Identifier>> textureGroups = groupTextures(resourceManager);

            // Process each group
            for (Map.Entry<String, List<Identifier>> entry : textureGroups.entrySet()) {
                processTextureGroup(entry.getKey(), entry.getValue(), resourceManager, outputDir);
            }

            Repal.LOGGER.info("Resource pack generation complete: {}", outputDir);

        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process textures", e);
        }
    }

    private static void createPackMcmeta(Path outputDir) throws IOException {
        JsonObject pack = new JsonObject();
        pack.addProperty("pack_format", 15); // Minecraft 1.21 pack format
        pack.addProperty("description", "Generated by Repal - " + Repal.getPackName());

        JsonObject root = new JsonObject();
        root.add("pack", pack);

        Files.write(
                outputDir.resolve("pack.mcmeta"),
                GSON.toJson(root).getBytes()
        );
    }

    private static Map<String, List<Identifier>> groupTextures(ResourceManager resourceManager) {
        Map<String, List<Identifier>> groups = new HashMap<>();

        // Initialize groups for all suffixes
        for (String suffix : COMMON_SUFFIXES) {
            groups.put(suffix, new ArrayList<>());
        }

        // Find all block textures
        resourceManager.findResources("textures/block", id ->
                BLOCK_TEXTURE_PATTERN.matcher(id.getPath()).matches()
        ).forEach((identifier, resource) -> {
            String path = identifier.getPath();
            String filename = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));

            // Find matching suffix
            String matchedSuffix = findMatchingSuffix(filename);
            groups.get(matchedSuffix).add(identifier);
        });

        // Remove empty groups
        groups.entrySet().removeIf(entry -> entry.getValue().isEmpty());

        return groups;
    }

    private static String findMatchingSuffix(String filename) {
        for (String suffix : COMMON_SUFFIXES) {
            if (filename.endsWith(suffix)) {
                return suffix;
            }
        }
        return ""; // Default group for no suffix match
    }

    private static void processTextureGroup(
            String suffix,
            List<Identifier> textures,
            ResourceManager resourceManager,
            Path outputDir
    ) {
        try {
            Repal.LOGGER.info("Processing texture group '{}' with {} textures",
                    suffix.isEmpty() ? "default" : suffix, textures.size());

            Set<Integer> uniqueInputColors = new HashSet<>();
            int processedCount = 0;

            // First pass: collect all unique colors
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            uniqueInputColors.add(image.getRGB(x, y));
                        }
                    }
                }
            }

            // Process each texture
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    BufferedImage processed = ImageProcessor.processImage(
                            image,
                            RepalResourceReloadListener.getCurrentPaletteColors(),
                            Repal.getPreContrast(),
                            Repal.getPreSaturation()
                    );

                    // Save processed texture
                    String relativePath = id.getPath().substring("textures/".length());
                    Path outputPath = outputDir.resolve("assets/minecraft/textures").resolve(relativePath);
                    Files.createDirectories(outputPath.getParent());
                    ImageIO.write(processed, "png", outputPath.toFile());

                    processedCount++;
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to process texture {}", id, e);
                }
            }

            Repal.LOGGER.info("Group '{}' complete: {} unique input colors, {} textures processed",
                    suffix.isEmpty() ? "default" : suffix,
                    uniqueInputColors.size(),
                    processedCount);

        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process texture group '{}'", suffix, e);
        }
    }
}