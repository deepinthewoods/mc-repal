This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T12:50:57.678Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitattributes
.github/workflows/build.yml
.gitignore
build.gradle
gradle.properties
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
LICENSE
repomixx.bat
settings.gradle
src/client/java/ninja/trek/config/RepalConfigScreen.java
src/client/java/ninja/trek/config/RepalModMenu.java
src/client/java/ninja/trek/ImageProcessor.java
src/client/java/ninja/trek/mixin/client/ExampleClientMixin.java
src/client/java/ninja/trek/RepalClient.java
src/client/java/ninja/trek/RepalDataGenerator.java
src/client/java/ninja/trek/TextureProcessor.java
src/client/resources/repal.client.mixins.json
src/main/java/ninja/trek/config/RepalConfig.java
src/main/java/ninja/trek/mixin/ExampleMixin.java
src/main/java/ninja/trek/Repal.java
src/main/java/ninja/trek/RepalResourceReloadListener.java
src/main/resources/assets/repal/lang/en_us.json
src/main/resources/fabric.mod.json
src/main/resources/repal.mixins.json
src/repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
#
# https://help.github.com/articles/dealing-with-line-endings/
#
# Linux start script should use lf
/gradlew        text eol=lf

# These are Windows script files and should use crlf
*.bat           text eol=crlf
</file>

<file path=".github/workflows/build.yml">
# Automatically build the project and run any configured tests for every push
# and submitted pull request. This can help catch issues that only occur on
# certain platforms or Java versions, and provides a first line of defence
# against bad commits.
name: build
on: [pull_request, push]
jobs:
  build:
    strategy:
      matrix:
        # Use these Java versions
        java: [
          21,    # Current Java LTS
        ]
    runs-on: ubuntu-22.04
    steps:
      - name: checkout repository
        uses: actions/checkout@v4
      - name: validate gradle wrapper
        uses: gradle/actions/wrapper-validation@v4
      - name: setup jdk ${{ matrix.java }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java }}
          distribution: 'microsoft'
      - name: make gradle wrapper executable
        run: chmod +x ./gradlew
      - name: build
        run: ./gradlew build
      - name: capture build artifacts
        if: ${{ matrix.java == '21' }} # Only upload artifacts built from latest java
        uses: actions/upload-artifact@v4
        with:
          name: Artifacts
          path: build/libs/
</file>

<file path=".gitignore">
# gradle

.gradle/
build/
out/
classes/

# eclipse

*.launch

# idea

.idea/
*.iml
*.ipr
*.iws

# vscode

.settings/
.vscode/
bin/
.classpath
.project

# macos

*.DS_Store

# fabric

run/

# java

hs_err_*.log
replay_*.log
*.hprof
*.jfr
</file>

<file path="build.gradle">
plugins {
	id 'fabric-loom' version '1.9-SNAPSHOT'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	// Add repositories to retrieve artifacts from in here.
	// You should only use this when depending on other mods because
	// Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html
	// for more information about repositories.

	maven { url "https://maven.terraformersmc.com/releases/" }  // For ModMenu
	maven { url "https://maven.shedaniel.me/" }  // For Cloth Config
}

loom {
	splitEnvironmentSourceSets()

	mods {
		"repal" {
			sourceSet sourceSets.main
			sourceSet sourceSets.client
		}
	}

}

fabricApi {
	configureDataGeneration {
		client = true
	}
}

dependencies {
	// To change the versions see the gradle.properties file
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

	// Fabric API. This is technically optional, but you probably want it anyway.
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
	modImplementation "com.terraformersmc:modmenu:${modmenu_version}"
	modImplementation "me.shedaniel.cloth:cloth-config-fabric:${cloth_config_version}"
}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 21
}

java {
	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
	// if it is present.
	// If you remove this line, sources will not be generated.
	withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

jar {
	from("LICENSE") {
		rename { "${it}_${project.base.archivesName.get()}"}
	}
}

// configure the maven publication
publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}

	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {
		// Add repositories to publish to here.
		// Notice: This block does NOT have the same function as the block in the top level.
		// The repositories here will be used for publishing your artifact, not for
		// retrieving dependencies.
	}
}
</file>

<file path="gradle.properties">
# Done to increase the memory available to gradle.
org.gradle.jvmargs=-Xmx1G
org.gradle.parallel=true

# Fabric Properties
# check these on https://fabricmc.net/develop
minecraft_version=1.21.4
yarn_mappings=1.21.4+build.8
loader_version=0.16.10

# Mod Properties
mod_version=1.0.0
maven_group=ninja.trek
archives_base_name=repal

# Dependencies
fabric_version=0.115.1+1.21.4
modmenu_version=11.0.3
cloth_config_version=15.0.140
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="LICENSE">
Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works ("Commons") that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the "Affirmer"), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
"License"). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

<file path="settings.gradle">
pluginManagement {
	repositories {
		maven {
			name = 'Fabric'
			url = 'https://maven.fabricmc.net/'
		}
		mavenCentral()
		gradlePluginPortal()
	}
}
</file>

<file path="src/client/java/ninja/trek/config/RepalConfigScreen.java">
package ninja.trek.config;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import net.minecraft.client.render.RenderLayer;
import ninja.trek.Repal;
import ninja.trek.RepalClient;
import ninja.trek.ImageProcessor;
import ninja.trek.RepalResourceReloadListener;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
public class RepalConfigScreen extends Screen {
    private static final Identifier GRASS_PREVIEW = Identifier.of("minecraft", "textures/block/grass_block_top.png");
    private final Screen parent;
    private SliderWidget contrastSlider;
    private SliderWidget saturationSlider;
    private ButtonWidget paletteButton;
    private TextFieldWidget packNameField;
    private ButtonWidget processButton;
    private BufferedImage originalPreview;
    public RepalConfigScreen(Screen parent) {
        super(Text.translatable("repal.config.title"));
        this.parent = parent;
    }
    @Override
    protected void init() {
        int centerX = width / 2;
        int startY = height / 4;
        // Load preview texture
        loadPreviewTexture();
    }
    private void loadPreviewTexture() {
        try {
            // Load original grass texture
            InputStream stream = client.getResourceManager()
                    .getResource(GRASS_PREVIEW)
                    .get()
                    .getInputStream();
            originalPreview = ImageIO.read(stream);
            updatePreview();
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to load preview texture", e);
        }
    }
    private void updatePreview() {
        if (originalPreview == null) return;
        try {
            // Process the preview image
            BufferedImage processed = ImageProcessor.processImage(
                    originalPreview,
                    RepalResourceReloadListener.getCurrentPaletteColors(),
                    Repal.getPreContrast(),
                    Repal.getPreSaturation()
            );
            // Convert BufferedImage to NativeImage
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            ImageIO.write(processed, "png", os);
            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
            NativeImage nativeImage = NativeImage.read(is);
            // Update the texture
            RepalClient.updatePreviewTexture(nativeImage);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to update preview", e);
        }
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        renderBackground(context, mouseX, mouseY, delta);
        // Draw original
        context.drawTexture(
                RenderLayer::getEntitySolid,
                GRASS_PREVIEW,
                width / 4 - 32,
                height / 2,
                0,
                0,
                64,
                64,
                64,
                64
        );
        // Draw processed
        context.drawTexture(
                RenderLayer::getEntitySolid,
                RepalClient.PREVIEW_TEXTURE_ID,
                3 * width / 4 - 32,
                height / 2,
                0,
                0,
                64,
                64,
                64,
                64
        );
        // Labels
        context.drawCenteredTextWithShadow(
                textRenderer,
                Text.translatable("repal.preview.original"),
                width / 4,
                height / 2 - 20,
                0xFFFFFF
        );
        context.drawCenteredTextWithShadow(
                textRenderer,
                Text.translatable("repal.preview.processed"),
                3 * width / 4,
                height / 2 - 20,
                0xFFFFFF
        );
        super.render(context, mouseX, mouseY, delta);
    }
    @Override
    public void removed() {
        super.removed();
    }
}
</file>

<file path="src/client/java/ninja/trek/config/RepalModMenu.java">
package ninja.trek.config;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.text.Text;
import ninja.trek.Repal;
import ninja.trek.config.RepalConfig;
public class RepalModMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> {
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(parent)
                    .setTitle(Text.translatable("repal.config.title"))
                    .setSavingRunnable(() -> {
                        // Save config when changes are applied
                        RepalConfig.save();
                    });
            ConfigCategory general = builder.getOrCreateCategory(
                    Text.translatable("repal.config.category.general")
            );
            ConfigEntryBuilder entryBuilder = builder.entryBuilder();
            // Pre-Contrast Slider
            general.addEntry(entryBuilder.startIntSlider(
                            Text.translatable("repal.config.contrast"),
                            RepalConfig.get().preContrast(),
                            Repal.MIN_ADJUSTMENT,
                            Repal.MAX_ADJUSTMENT)
                    .setDefaultValue(0)
                    .setTooltip(Text.translatable("repal.tooltip.contrast"))
                    .setSaveConsumer(value -> RepalConfig.get().setPreContrast(value))
                    .build()
            );
            // Pre-Saturation Slider
            general.addEntry(entryBuilder.startIntSlider(
                            Text.translatable("repal.config.saturation"),
                            RepalConfig.get().preSaturation(),
                            Repal.MIN_ADJUSTMENT,
                            Repal.MAX_ADJUSTMENT)
                    .setDefaultValue(0)
                    .setTooltip(Text.translatable("repal.tooltip.saturation"))
                    .setSaveConsumer(value -> RepalConfig.get().setPreSaturation(value))
                    .build()
            );
            // Palette Selection
            general.addEntry(entryBuilder.startIntField(
                            Text.translatable("repal.config.palette"),
                            RepalConfig.get().selectedPalette())
                    .setDefaultValue(1)
                    .setMin(1)
                    .setMax(2)
                    .setTooltip(Text.translatable("repal.tooltip.palette"))
                    .setSaveConsumer(value -> RepalConfig.get().setSelectedPalette(value))
                    .build()
            );
            // Pack Name Field
            general.addEntry(entryBuilder.startStrField(
                            Text.translatable("repal.config.pack_name"),
                            RepalConfig.get().packName())
                    .setDefaultValue("repal")
                    .setTooltip(Text.translatable("repal.tooltip.pack_name"))
                    .setSaveConsumer(value -> RepalConfig.get().setPackName(value))
                    .build()
            );
            return builder.build();
        };
    }
}
</file>

<file path="src/client/java/ninja/trek/ImageProcessor.java">
package ninja.trek;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.util.*;
public class ImageProcessor {
    // Cache for color mappings to improve performance when processing multiple textures
    private static final Map<Color, Color> colorMappingCache = new HashMap<>();
    public static BufferedImage processImage(BufferedImage input, List<Color> targetPalette, int contrast, int saturation) {
        if (targetPalette.isEmpty()) {
            return input;
        }
        BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), BufferedImage.TYPE_INT_ARGB);
        // Pre-process adjustments
        float contrastFactor = (100.0f + contrast) / 100.0f;
        float saturationFactor = (100.0f + saturation) / 100.0f;
        // Process each pixel
        for (int y = 0; y < input.getHeight(); y++) {
            for (int x = 0; x < input.getWidth(); x++) {
                Color inputColor = new Color(input.getRGB(x, y), true);
                // Skip fully transparent pixels
                if (inputColor.getAlpha() == 0) {
                    output.setRGB(x, y, inputColor.getRGB());
                    continue;
                }
                // Apply pre-processing
                Color adjustedColor = adjustColor(inputColor, contrastFactor, saturationFactor);
                // Find closest palette color
                Color mappedColor = colorMappingCache.computeIfAbsent(adjustedColor,
                        color -> findClosestPaletteColor(color, targetPalette));
                // Preserve original alpha
                Color finalColor = new Color(
                        mappedColor.getRed(),
                        mappedColor.getGreen(),
                        mappedColor.getBlue(),
                        inputColor.getAlpha()
                );
                output.setRGB(x, y, finalColor.getRGB());
            }
        }
        return output;
    }
    private static Color adjustColor(Color input, float contrastFactor, float saturationFactor) {
        float[] hsb = Color.RGBtoHSB(input.getRed(), input.getGreen(), input.getBlue(), null);
        // Adjust saturation
        hsb[1] = Math.max(0.0f, Math.min(1.0f, hsb[1] * saturationFactor));
        // Adjust contrast (using brightness)
        float adjustedBrightness = ((hsb[2] - 0.5f) * contrastFactor) + 0.5f;
        hsb[2] = Math.max(0.0f, Math.min(1.0f, adjustedBrightness));
        // Convert back to RGB
        int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
        return new Color(rgb);
    }
    private static Color findClosestPaletteColor(Color input, List<Color> palette) {
        Color closestColor = palette.get(0);
        double minDistance = Double.MAX_VALUE;
        for (Color paletteColor : palette) {
            double distance = calculateColorDistance(input, paletteColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = paletteColor;
            }
        }
        return closestColor;
    }
    private static double calculateColorDistance(Color c1, Color c2) {
        // Using CIE76 color difference formula
        // Convert RGB to Lab color space for better color comparison
        double[] lab1 = rgbToLab(c1);
        double[] lab2 = rgbToLab(c2);
        // Calculate Euclidean distance in Lab space
        double deltaL = lab1[0] - lab2[0];
        double deltaA = lab1[1] - lab2[1];
        double deltaB = lab1[2] - lab2[2];
        return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
    }
    private static double[] rgbToLab(Color color) {
        // RGB to XYZ
        double r = color.getRed() / 255.0;
        double g = color.getGreen() / 255.0;
        double b = color.getBlue() / 255.0;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        double x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
        double y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
        double z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
        // XYZ to Lab
        x /= 95.047;
        y /= 100.000;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1.0/3.0) : (7.787 * x) + 16.0/116.0;
        y = y > 0.008856 ? Math.pow(y, 1.0/3.0) : (7.787 * y) + 16.0/116.0;
        z = z > 0.008856 ? Math.pow(z, 1.0/3.0) : (7.787 * z) + 16.0/116.0;
        return new double[] {
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
        };
    }
    public static void clearCache() {
        colorMappingCache.clear();
    }
}
</file>

<file path="src/client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="src/client/java/ninja/trek/RepalClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;
import ninja.trek.Repal;
public class RepalClient implements ClientModInitializer {
	private static NativeImageBackedTexture previewTexture;
	public static final Identifier PREVIEW_TEXTURE_ID = Identifier.of(Repal.MOD_ID, "preview");
	@Override
	public void onInitializeClient() {
		ClientLifecycleEvents.CLIENT_STARTED.register(client -> {
			initializePreviewTexture(client);
		});
		ClientLifecycleEvents.CLIENT_STOPPING.register(client -> {
			if (previewTexture != null) {
				client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
				previewTexture.close();
				previewTexture = null;
			}
		});
	}
	private void initializePreviewTexture(MinecraftClient client) {
		try {
			NativeImage image = new NativeImage(NativeImage.Format.RGBA, 16, 16, true);
			for (int x = 0; x < 16; x++) {
				for (int y = 0; y < 16; y++) {
					int color = (x + y) % 2 == 0 ? 0xFF808080 : 0xFFCCCCCC;
					image.setColorArgb(x, y, color);
				}
			}
			previewTexture = new NativeImageBackedTexture(image);
			client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
		} catch (Exception e) {
			Repal.LOGGER.error("Failed to initialize preview texture", e);
		}
	}
	public static void updatePreviewTexture(NativeImage newImage) {
		MinecraftClient client = MinecraftClient.getInstance();
		if (previewTexture != null) {
			client.getTextureManager().destroyTexture(PREVIEW_TEXTURE_ID);
			previewTexture.close();
		}
		previewTexture = new NativeImageBackedTexture(newImage);
		client.getTextureManager().registerTexture(PREVIEW_TEXTURE_ID, previewTexture);
	}
}
</file>

<file path="src/client/java/ninja/trek/RepalDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class RepalDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="src/client/java/ninja/trek/TextureProcessor.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import net.fabricmc.loader.api.FabricLoader;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
public class TextureProcessor {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final String[] COMMON_SUFFIXES = {
            "_top", "_bottom", "_side", "_front", "_back",
            "_base", "_overlay", "_particle", "_layer_1", "_layer_2",
            "", "_all", "_planks", "_log", "_stem",
            "_leaves", "_door_top", "_door_bottom"
    };
    private static final Pattern BLOCK_TEXTURE_PATTERN = Pattern.compile("textures/block/.*\\.png");
    public static void processAllTextures() {
        try {
            ResourceManager resourceManager = MinecraftClient.getInstance().getResourceManager();
            Path outputDir = FabricLoader.getInstance().getGameDir()
                    .resolve("resourcepacks")
                    .resolve(Repal.getPackName());
            // Create resource pack directory structure
            Files.createDirectories(outputDir.resolve("assets/minecraft/textures/block"));
            // Create pack.mcmeta
            createPackMcmeta(outputDir);
            // Group textures by suffix
            Map<String, List<Identifier>> textureGroups = groupTextures(resourceManager);
            // Process each group
            for (Map.Entry<String, List<Identifier>> entry : textureGroups.entrySet()) {
                processTextureGroup(entry.getKey(), entry.getValue(), resourceManager, outputDir);
            }
            Repal.LOGGER.info("Resource pack generation complete: {}", outputDir);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process textures", e);
        }
    }
    private static void createPackMcmeta(Path outputDir) throws IOException {
        JsonObject pack = new JsonObject();
        pack.addProperty("pack_format", 15); // Minecraft 1.21 pack format
        pack.addProperty("description", "Generated by Repal - " + Repal.getPackName());
        JsonObject root = new JsonObject();
        root.add("pack", pack);
        Files.write(
                outputDir.resolve("pack.mcmeta"),
                GSON.toJson(root).getBytes()
        );
    }
    private static Map<String, List<Identifier>> groupTextures(ResourceManager resourceManager) {
        Map<String, List<Identifier>> groups = new HashMap<>();
        // Initialize groups for all suffixes
        for (String suffix : COMMON_SUFFIXES) {
            groups.put(suffix, new ArrayList<>());
        }
        // Find all block textures
        resourceManager.findResources("textures/block", id ->
                BLOCK_TEXTURE_PATTERN.matcher(id.getPath()).matches()
        ).forEach((identifier, resource) -> {
            String path = identifier.getPath();
            String filename = path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.'));
            // Find matching suffix
            String matchedSuffix = findMatchingSuffix(filename);
            groups.get(matchedSuffix).add(identifier);
        });
        // Remove empty groups
        groups.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return groups;
    }
    private static String findMatchingSuffix(String filename) {
        for (String suffix : COMMON_SUFFIXES) {
            if (filename.endsWith(suffix)) {
                return suffix;
            }
        }
        return ""; // Default group for no suffix match
    }
    private static void processTextureGroup(
            String suffix,
            List<Identifier> textures,
            ResourceManager resourceManager,
            Path outputDir
    ) {
        try {
            Repal.LOGGER.info("Processing texture group '{}' with {} textures",
                    suffix.isEmpty() ? "default" : suffix, textures.size());
            Set<Integer> uniqueInputColors = new HashSet<>();
            int processedCount = 0;
            // First pass: collect all unique colors
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            uniqueInputColors.add(image.getRGB(x, y));
                        }
                    }
                }
            }
            // Process each texture
            for (Identifier id : textures) {
                try (InputStream stream = resourceManager.getResource(id).get().getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    BufferedImage processed = ImageProcessor.processImage(
                            image,
                            RepalResourceReloadListener.getCurrentPaletteColors(),
                            Repal.getPreContrast(),
                            Repal.getPreSaturation()
                    );
                    // Save processed texture
                    String relativePath = id.getPath().substring("textures/".length());
                    Path outputPath = outputDir.resolve("assets/minecraft/textures").resolve(relativePath);
                    Files.createDirectories(outputPath.getParent());
                    ImageIO.write(processed, "png", outputPath.toFile());
                    processedCount++;
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to process texture {}", id, e);
                }
            }
            Repal.LOGGER.info("Group '{}' complete: {} unique input colors, {} textures processed",
                    suffix.isEmpty() ? "default" : suffix,
                    uniqueInputColors.size(),
                    processedCount);
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to process texture group '{}'", suffix, e);
        }
    }
}
</file>

<file path="src/client/resources/repal.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="src/main/java/ninja/trek/config/RepalConfig.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import ninja.trek.Repal;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
public class RepalConfig {
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();
    private static final Path CONFIG_PATH = FabricLoader.getInstance()
            .getConfigDir()
            .resolve("repal.json");
    private static RepalConfig INSTANCE;
    private int preContrast = 0;
    private int preSaturation = 0;
    private int selectedPalette = 1;
    private String packName = "repal";
    // Private constructor to enforce singleton
    private RepalConfig() {}
    public static RepalConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        if (Files.exists(CONFIG_PATH)) {
            try (Reader reader = Files.newBufferedReader(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(reader, RepalConfig.class);
                if (INSTANCE == null) {
                    INSTANCE = new RepalConfig();
                }
            } catch (Exception e) {
                Repal.LOGGER.error("Failed to load config: ", e);
                INSTANCE = new RepalConfig();
            }
        } else {
            INSTANCE = new RepalConfig();
            save();
        }
    }
    public static void save() {
        try {
            Files.createDirectories(CONFIG_PATH.getParent());
            try (Writer writer = Files.newBufferedWriter(CONFIG_PATH)) {
                GSON.toJson(get(), writer);
            }
        } catch (Exception e) {
            Repal.LOGGER.error("Failed to save config: ", e);
        }
    }
    // Getters
    public int preContrast() {
        return preContrast;
    }
    public int preSaturation() {
        return preSaturation;
    }
    public int selectedPalette() {
        return selectedPalette;
    }
    public String packName() {
        return packName;
    }
    // Setters with validation
    public void setPreContrast(int value) {
        this.preContrast = Math.min(Math.max(value, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
        save();
    }
    public void setPreSaturation(int value) {
        this.preSaturation = Math.min(Math.max(value, Repal.MIN_ADJUSTMENT), Repal.MAX_ADJUSTMENT);
        save();
    }
    public void setSelectedPalette(int value) {
        this.selectedPalette = (value == 1 || value == 2) ? value : 1;
        save();
    }
    public void setPackName(String name) {
        this.packName = name == null || name.trim().isEmpty() ? "repal" : name.trim();
        save();
    }
}
</file>

<file path="src/main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="src/main/java/ninja/trek/Repal.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ninja.trek.config.RepalConfig;
public class Repal implements ModInitializer {
	public static final String MOD_ID = "repal";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	// Identifiers for our palette resources
	public static final Identifier PALETTE_1 = Identifier.of(MOD_ID, "textures/palette/pal1.png");
	public static final Identifier PALETTE_2 = Identifier.of(MOD_ID, "textures/palette/pal2.png");
	// Settings constants
	public static final int MIN_ADJUSTMENT = -100;
	public static final int MAX_ADJUSTMENT = 100;
	public static final int DEFAULT_ADJUSTMENT = 0;
	@Override
	public void onInitialize() {
		LOGGER.info("Initializing Repal - Texture Recoloring Mod");
		// Load config
		RepalConfig.load();
		// Register resource reload listener
		ResourceManagerHelper.get(ResourceType.CLIENT_RESOURCES)
				.registerReloadListener(new RepalResourceReloadListener());
	}
	// Static access methods that use the config
	public static int getPreContrast() {
		return RepalConfig.get().preContrast();
	}
	public static int getPreSaturation() {
		return RepalConfig.get().preSaturation();
	}
	public static int getSelectedPalette() {
		return RepalConfig.get().selectedPalette();
	}
	public static String getPackName() {
		return RepalConfig.get().packName();
	}
	public static void setPreContrast(int value) {
		RepalConfig.get().setPreContrast(value);
	}
	public static void setPreSaturation(int value) {
		RepalConfig.get().setPreSaturation(value);
	}
	public static void setSelectedPalette(int value) {
		RepalConfig.get().setSelectedPalette(value);
	}
	public static void setPackName(String name) {
		RepalConfig.get().setPackName(name);
	}
}
</file>

<file path="src/main/java/ninja/trek/RepalResourceReloadListener.java">
package ninja.trek;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.util.Identifier;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.awt.Color;
public class RepalResourceReloadListener implements SimpleSynchronousResourceReloadListener {
    private static List<Color> palette1Colors = new ArrayList<>();
    private static List<Color> palette2Colors = new ArrayList<>();
    @Override
    public void reload(ResourceManager manager) {
        // Load both palettes
        loadPalette(manager, Repal.PALETTE_1, palette1Colors);
        loadPalette(manager, Repal.PALETTE_2, palette2Colors);
    }
    private void loadPalette(ResourceManager manager, Identifier paletteId, List<Color> colorList) {
        colorList.clear();
        try {
            manager.getResource(paletteId).ifPresent(resource -> {
                try (InputStream stream = resource.getInputStream()) {
                    BufferedImage image = ImageIO.read(stream);
                    Set<Color> uniqueColors = new HashSet<>();
                    // Scan every pixel in the image
                    for (int y = 0; y < image.getHeight(); y++) {
                        for (int x = 0; x < image.getWidth(); x++) {
                            Color color = new Color(image.getRGB(x, y), true);
                            // Only add fully opaque colors or fully transparent
                            if (color.getAlpha() == 255 || color.getAlpha() == 0) {
                                uniqueColors.add(color);
                            }
                        }
                    }
                    colorList.addAll(uniqueColors);
                    Repal.LOGGER.info("Loaded {} colors from palette {}", uniqueColors.size(), paletteId);
                } catch (Exception e) {
                    Repal.LOGGER.error("Failed to load palette {}: {}", paletteId, e.getMessage());
                }
            });
        } catch (Exception e) {
            Repal.LOGGER.error("Error accessing palette {}: {}", paletteId, e.getMessage());
        }
    }
    // Getters for the palette colors
    public static List<Color> getPalette1Colors() {
        return new ArrayList<>(palette1Colors);
    }
    public static List<Color> getPalette2Colors() {
        return new ArrayList<>(palette2Colors);
    }
    // Get currently selected palette colors
    public static List<Color> getCurrentPaletteColors() {
        return Repal.getSelectedPalette() == 1 ? getPalette1Colors() : getPalette2Colors();
    }
    @Override
    public Identifier getFabricId() {
        return Identifier.of(Repal.MOD_ID, "textures");
    }
}
</file>

<file path="src/main/resources/assets/repal/lang/en_us.json">
// assets/repal/lang/en_us.json
{
  "repal.config.title": "Repal Settings",
  "repal.config.contrast": "Pre-Contrast: %d",
  "repal.config.saturation": "Pre-Saturation: %d",
  "repal.config.palette": "Palette: %d",
  "repal.config.process": "Process Textures",
  "repal.preview.original": "Original",
  "repal.preview.processed": "Processed",
  "repal.status.processing": "Processing textures...",
  "repal.status.complete": "Resource pack generated: %s",
  "repal.status.failed": "Failed to generate resource pack",
  "repal.tooltip.contrast": "Adjusts contrast before palette mapping (-100 to 100)",
  "repal.tooltip.saturation": "Adjusts saturation before palette mapping (-100 to 100)",
  "repal.tooltip.palette": "Select palette to use for recoloring",
  "repal.tooltip.process": "Generate a new resource pack with recolored textures"
}
</file>

<file path="src/main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "repal",
	"version": "${version}",
	"name": "Repal",
	"description": "A mod for recoloring Minecraft textures using custom palettes",
	"authors": [
		"trek"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/trek/repal"
	},
	"license": "MIT",
	"icon": "assets/repal/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.Repal"
		],
		"client": [
			"ninja.trek.RepalClient"
		],
		"modmenu": [
			"ninja.trek.config.RepalModMenu"
		],
		"fabric-datagen": [
			"ninja.trek.RepalDataGenerator"
		]
	},
	"mixins": [
		"repal.mixins.json"
	],
	"depends": {
		"fabricloader": ">=0.14.21",
		"minecraft": "~1.21.4",
		"java": ">=17",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	},
	"recommends": {
		"modmenu": ">=11.0.3",
		"cloth-config": ">=13.0.121"
	},
	"custom": {
		"modmenu": {
			"links": {
				"modmenu.discord": "https://discord.gg/fabric",
				"modmenu.issues": "https://github.com/trek/repal/issues"
			}
		}
	}
}
</file>

<file path="src/main/resources/repal.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="src/repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
